<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Props & State - Interactive Learning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.5em;
        }

        .hindi-text {
            color: #555;
            font-style: italic;
            margin: 10px 0;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .interactive-demo {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            border: 2px solid #667eea;
        }

        .demo-box {
            display: inline-block;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .parent-box {
            background: #667eea;
            color: white;
        }

        .child-box {
            background: #764ba2;
            color: white;
        }

        .state-box {
            background: #48bb78;
            color: white;
        }

        .demo-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .counter-display {
            font-size: 3em;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
        }

        .comparison-table th, .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .comparison-table tr:hover {
            background: #f7fafc;
        }

        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .flow-box {
            padding: 20px;
            border-radius: 10px;
            font-weight: bold;
            min-width: 120px;
            text-align: center;
        }

        .arrow {
            font-size: 2em;
            color: #667eea;
        }

        .questions-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 40px;
        }

        .question-card {
            background: white;
            color: #333;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .question-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .difficulty {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .easy { background: #48bb78; color: white; }
        .medium { background: #ed8936; color: white; }
        .hard { background: #f56565; color: white; }

        .toggle-answer {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .answer {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .props-flow {
            position: relative;
            padding: 20px;
            margin: 20px 0;
        }

        .component-level {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }

        .component-node {
            background: #667eea;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            position: relative;
            animation: fadeIn 0.5s;
        }

        .drilling-demo .component-node {
            margin: 0 10px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .hook-demo {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .hook-output {
            background: #2d2d2d;
            color: #48bb78;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            margin-top: 10px;
        }

        input[type="text"] {
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            margin: 10px 5px;
            width: 200px;
        }

        .batch-demo {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .batch-demo {
                grid-template-columns: 1fr;
            }
            
            header h1 {
                font-size: 1.8em;
            }
            
            .content {
                padding: 20px;
            }
        }

        .highlight {
            background: #fef3c7;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        .warning-box {
            background: #fed7d7;
            border-left: 4px solid #f56565;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success-box {
            background: #c6f6d5;
            border-left: 4px solid #48bb78;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ React Props & State</h1>
            <p>Day 9-11: Complete Interactive Guide</p>
        </header>

        <div class="content">
            <!-- Props Section -->
            <div class="section">
                <h2>üì¶ Props (Properties)</h2>
                
                <p class="hindi-text">
                    Props matlab <strong>properties</strong> - ye woh data hai jo aap ek component se dusre component mein pass karte ho. 
                    Socho jaise aap apne dost ko koi cheez dete ho - woh cheez props hai!
                </p>

                <h3>Key Concept: Immutable Data</h3>
                <p><strong>Definition:</strong> Props are <span class="highlight">read-only</span> and cannot be modified by the component that receives them.</p>
                
                <p class="hindi-text">
                    Immutable ka matlab - jo change nahi ho sakta. Jab aapko koi props milta hai, aap use modify nahi kar sakte, 
                    sirf read kar sakte ho. Ye React ka important rule hai!
                </p>

                <div class="code-block">
// Parent Component
function Parent() {
    const userName = "Raj";
    return &lt;Child name={userName} age={25} /&gt;;
}

// Child Component - Props read karna
function Child(props) {
    // ‚ùå WRONG - Props ko change nahi kar sakte
    // props.name = "Simran"; 
    
    // ‚úÖ CORRECT - Sirf read karo
    return &lt;h1&gt;Hello {props.name}, Age: {props.age}&lt;/h1&gt;;
}
                </div>

                <div class="interactive-demo">
                    <h4>Interactive Props Demo</h4>
                    <p>Neeche ke boxes parent-child relationship dikhate hain:</p>
                    <div style="text-align: center;">
                        <div class="demo-box parent-box">
                            Parent Component<br>
                            <small>Data: "Hello from Parent"</small>
                        </div>
                        <div class="arrow">‚Üì</div>
                        <div class="demo-box child-box" id="childBox">
                            Child Component<br>
                            <small id="childData">Waiting for props...</small>
                        </div>
                        <br><br>
                        <button class="btn" onclick="passProps()">Pass Props</button>
                        <button class="btn" onclick="resetProps()">Reset</button>
                    </div>
                </div>
            </div>

            <!-- Props Drilling Problem -->
            <div class="section">
                <h2>üï≥Ô∏è Props Drilling Problem</h2>
                
                <p class="hindi-text">
                    Jab aapko bahut saare components ke through props pass karne padte hain tab problem hoti hai. 
                    Ye drilling jaisi feel hoti hai - jaise zameen mein drill kar rahe ho!
                </p>

                <p><strong>Definition:</strong> Props drilling occurs when you need to pass data through multiple intermediate components that don't need the data themselves.</p>

                <div class="interactive-demo drilling-demo">
                    <h4>Props Drilling Visualization</h4>
                    <div id="drillingVisualization">
                        <div class="component-level">
                            <div class="component-node">GrandParent (data: "Top Secret")</div>
                        </div>
                        <div style="text-align: center; color: #667eea;">‚Üì props</div>
                        <div class="component-level">
                            <div class="component-node">Parent (doesn't need it)</div>
                        </div>
                        <div style="text-align: center; color: #667eea;">‚Üì props</div>
                        <div class="component-level">
                            <div class="component-node">Child (doesn't need it)</div>
                        </div>
                        <div style="text-align: center; color: #667eea;">‚Üì props</div>
                        <div class="component-level">
                            <div class="component-node">GrandChild (finally uses it!)</div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; text-align: center;">
                        Dekho kitne components se data pass ho raha hai jabki sirf last wale ko chahiye!
                    </p>
                </div>

                <div class="warning-box">
                    <strong>‚ö†Ô∏è Problem:</strong> Bahut saare unnecessary components ko props pass karna padta hai, 
                    code maintain karna mushkil ho jata hai. Solution: Context API ya State Management libraries.
                </div>
            </div>

            <!-- State vs Props -->
            <div class="section">
                <h2>‚öñÔ∏è State vs Props</h2>
                
                <p class="hindi-text">
                    State aur Props mein kya farak hai? Ye React ka sabse important concept hai!
                </p>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Props</th>
                            <th>State</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Data passed from parent to child</td>
                            <td>Data managed within component</td>
                        </tr>
                        <tr>
                            <td><strong>Mutability</strong></td>
                            <td>Immutable (change nahi ho sakta)</td>
                            <td>Mutable (change ho sakta hai)</td>
                        </tr>
                        <tr>
                            <td><strong>Controlled By</strong></td>
                            <td>Parent component</td>
                            <td>Component khud control karta hai</td>
                        </tr>
                        <tr>
                            <td><strong>Can Change?</strong></td>
                            <td>No (parent se naya props aaye to yes)</td>
                            <td>Yes (setState se)</td>
                        </tr>
                        <tr>
                            <td><strong>Re-render Trigger</strong></td>
                            <td>Jab parent naye props bheje</td>
                            <td>Jab setState call ho</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
// Props Example
function Welcome(props) {
    // props.name change nahi kar sakte
    return &lt;h1&gt;Welcome {props.name}&lt;/h1&gt;;
}

// State Example
function Counter() {
    const [count, setCount] = useState(0);
    
    // State ko change kar sakte hain
    const increment = () => setCount(count + 1);
    
    return &lt;button onClick={increment}&gt;Count: {count}&lt;/button&gt;;
}
                </div>
            </div>

            <!-- Local Component State -->
            <div class="section">
                <h2>üéØ Local Component State</h2>
                
                <p class="hindi-text">
                    Local state matlab sirf us component ka apna data. Jaise aapki personal diary - 
                    sirf aap hi read aur write kar sakte ho!
                </p>

                <p><strong>Definition:</strong> Local state is data that belongs to and is managed by a single component. It's private and fully controlled by that component.</p>

                <div class="interactive-demo">
                    <h4>Interactive Counter Demo</h4>
                    <div class="counter-display" id="counterDisplay">0</div>
                    <div style="text-align: center;">
                        <button class="btn" onclick="incrementCounter()">‚ûï Increment</button>
                        <button class="btn" onclick="decrementCounter()">‚ûñ Decrement</button>
                        <button class="btn" onclick="resetCounter()">üîÑ Reset</button>
                    </div>
                    <p style="text-align: center; margin-top: 15px;">
                        Ye counter local state ka example hai - data sirf is component ke andar hai!
                    </p>
                </div>

                <div class="code-block">
function MyComponent() {
    // Local state - sirf is component ke liye
    const [name, setName] = useState("Raj");
    const [age, setAge] = useState(25);
    const [isActive, setIsActive] = useState(true);
    
    // Ye data bahar accessible nahi hai
    return (
        &lt;div&gt;
            &lt;p&gt;Name: {name}&lt;/p&gt;
            &lt;p&gt;Age: {age}&lt;/p&gt;
            &lt;p&gt;Status: {isActive ? "Active" : "Inactive"}&lt;/p&gt;
        &lt;/div&gt;
    );
}
                </div>
            </div>

            <!-- Updating State Correctly -->
            <div class="section">
                <h2>‚úÖ Updating State Correctly</h2>
                
                <p class="hindi-text">
                    State ko update karna aasan hai par sahi tarike se karna zaroori hai! 
                    Galat tarike se update kiya to bugs aa sakte hain.
                </p>

                <div class="warning-box">
                    <strong>‚ùå WRONG WAY:</strong>
                    <div class="code-block" style="margin-top: 10px;">
// Direct mutation - Ye GALAT hai!
state.count = state.count + 1;  // ‚ùå Never do this
state.items.push(newItem);      // ‚ùå Never do this
                    </div>
                </div>

                <div class="success-box">
                    <strong>‚úÖ CORRECT WAY:</strong>
                    <div class="code-block" style="margin-top: 10px;">
// Using setState function
const [count, setCount] = useState(0);
setCount(count + 1);  // ‚úÖ Correct

// For arrays - create new array
const [items, setItems] = useState([]);
setItems([...items, newItem]);  // ‚úÖ Correct

// For objects - create new object
const [user, setUser] = useState({name: "Raj"});
setUser({...user, age: 25});  // ‚úÖ Correct
                    </div>
                </div>

                <div class="interactive-demo">
                    <h4>State Update Demo</h4>
                    <div id="itemsList" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <strong>Items:</strong> <span id="items">[]</span>
                    </div>
                    <button class="btn" onclick="addItem()">Add Item</button>
                    <button class="btn" onclick="clearItems()">Clear All</button>
                </div>
            </div>

            <!-- Multiple State Updates Batching -->
            <div class="section">
                <h2>üé≠ Multiple State Updates Batching</h2>
                
                <p class="hindi-text">
                    React smart hai! Jab aap ek saath bahut saare state updates karte ho, 
                    React unhe ek saath batch kar deta hai performance ke liye.
                </p>

                <p><strong>Definition:</strong> React groups multiple setState calls into a single re-render for better performance. This is called batching.</p>

                <div class="batch-demo">
                    <div>
                        <h4>Without Batching (Old React)</h4>
                        <div class="code-block">
function handleClick() {
    setCount(c => c + 1);  // Re-render
    setFlag(f => !f);       // Re-render
    setName("Raj");         // Re-render
    // Total: 3 re-renders
}
                        </div>
                    </div>
                    <div>
                        <h4>With Batching (React 18+)</h4>
                        <div class="code-block">
function handleClick() {
    setCount(c => c + 1);
    setFlag(f => !f);
    setName("Raj");
    // Total: 1 re-render (batched!)
}
                        </div>
                    </div>
                </div>

                <div class="success-box">
                    <strong>üí° Pro Tip:</strong> React 18+ mein automatic batching hai. 
                    Matlab aapko kuch karna nahi padta, React khud optimize kar leta hai!
                </div>
            </div>

            <!-- Derived State Pitfalls -->
            <div class="section">
                <h2>‚ö†Ô∏è Derived State Pitfalls</h2>
                
                <p class="hindi-text">
                    Derived state matlab - jo state kisi aur state se calculate ho. 
                    Ye concept thoda tricky hai aur isme mistakes hona common hai!
                </p>

                <p><strong>Definition:</strong> Derived state is state that can be calculated from existing state or props. Creating unnecessary derived state is a common anti-pattern.</p>

                <div class="warning-box">
                    <strong>‚ùå BAD PATTERN - Unnecessary Derived State:</strong>
                    <div class="code-block" style="margin-top: 10px;">
function UserProfile({ user }) {
    // ‚ùå Ye zaroori nahi - directly calculate karo
    const [fullName, setFullName] = useState(
        `${user.firstName} ${user.lastName}`
    );
    
    // Problem: user change hone par fullName sync nahi rahega!
    return &lt;h1&gt;{fullName}&lt;/h1&gt;;
}
                    </div>
                </div>

                <div class="success-box">
                    <strong>‚úÖ GOOD PATTERN - Calculate During Render:</strong>
                    <div class="code-block" style="margin-top: 10px;">
function UserProfile({ user }) {
    // ‚úÖ Directly calculate - no extra state needed
    const fullName = `${user.firstName} ${user.lastName}`;
    
    // Hamesha sync rahega!
    return &lt;h1&gt;{fullName}&lt;/h1&gt;;
}
                    </div>
                </div>

                <div class="warning-box">
                    <strong>üéØ Rule of Thumb:</strong> Agar kuch calculate ho sakta hai existing state/props se, 
                    to naya state mat banao. Directly render time pe calculate karo!
                </div>
            </div>

            <!-- Hooks Introduction -->
            <div class="section">
                <h2>üé£ Introduction to Hooks</h2>
                
                <p class="hindi-text">
                    Hooks React ka game-changer feature hai! Hooks se aap functional components mein 
                    state aur lifecycle features use kar sakte ho - class components ki zaroorat nahi!
                </p>

                <p><strong>Definition:</strong> Hooks are functions that let you "hook into" React state and lifecycle features from function components.</p>

                <div class="success-box">
                    <strong>üéØ Rules of Hooks:</strong>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>‚úÖ Sirf top level pe call karo (loops/conditions mein nahi)</li>
                        <li>‚úÖ Sirf React functions mein call karo</li>
                        <li>‚úÖ Hook names always "use" se start hote hain</li>
                    </ul>
                </div>
            </div>

            <!-- useState Hook -->
            <div class="section">
                <h2>üîß useState Hook</h2>
                
                <p class="hindi-text">
                    useState sabse important aur basic hook hai. Isse functional components mein state use kar sakte ho!
                </p>

                <p><strong>Definition:</strong> useState is a Hook that lets you add state to functional components. It returns an array with the current state value and a function to update it.</p>

                <div class="code-block">
// Basic Syntax
const [state, setState] = useState(initialValue);

// Examples
const [count, setCount] = useState(0);           // Number
const [name, setName] = useState("Raj");         // String
const [isActive, setIsActive] = useState(true);  // Boolean
const [items, setItems] = useState([]);          // Array
const [user, setUser] = useState({});            // Object
                </div>

                <div class="interactive-demo hook-demo">
                    <h4>Live useState Demo</h4>
                    <input type="text" id="nameInput" placeholder="Enter your name" />
                    <button class="btn" onclick="updateName()">Update Name</button>
                    <div class="hook-output">
                        Current State: <span id="nameOutput">"Enter a name"</span>
                    </div>
                </div>

                <div class="code-block">
// Functional Updates - Previous state use karna
function Counter() {
    const [count, setCount] = useState(0);
    
    const increment = () => {
        // ‚úÖ Previous state use karo jab multiple updates ho
        setCount(prevCount => prevCount + 1);
    };
    
    const addFive = () => {
        // Ye 5 times correctly increment karega
        setCount(c => c + 1);
        setCount(c => c + 1);
        setCount(c => c + 1);
        setCount(c => c + 1);
        setCount(c => c + 1);
    };
    
    return &lt;button onClick={increment}&gt;{count}&lt;/button&gt;;
}
                </div>
            </div>

            <!-- useEffect Hook -->
            <div class="section">
                <h2>‚ö° useEffect Hook</h2>
                
                <p class="hindi-text">
                    useEffect side effects handle karne ke liye hai - jaise data fetching, 
                    subscriptions, ya DOM manipulation. Ye class components ke lifecycle methods ka alternative hai!
                </p>

                <p><strong>Definition:</strong> useEffect is a Hook that lets you perform side effects in functional components. It runs after every render by default.</p>

                <div class="code-block">
// Basic Syntax
useEffect(() => {
    // Side effect code yahan
    
    return () => {
        // Cleanup code (optional)
    };
}, [dependencies]);

// Example: Document title update
function MyComponent() {
    const [count, setCount] = useState(0);
    
    useEffect(() => {
        document.title = `Count: ${count}`;
    }, [count]);  // Sirf jab count change ho tab run hoga
    
    return &lt;button onClick={() => setCount(count + 1)}&gt;{count}&lt;/button&gt;;
}
                </div>

                <div class="interactive-demo hook-demo">
                    <h4>useEffect Demo</h4>
                    <button class="btn" onclick="startEffect()">Start Effect</button>
                    <button class="btn" onclick="stopEffect()">Stop Effect</button>
                    <div class="hook-output">
                        Effect Runs: <span id="effectCount">0</span> times<br>
                        Timer: <span id="timerValue">0</span>s
                    </div>
                </div>

                <div class="code-block">
// Different useEffect Patterns

// 1. Run on every render (no dependency array)
useEffect(() => {
    console.log("Har render pe chalega");
});

// 2. Run only once on mount (empty dependency array)
useEffect(() => {
    console.log("Sirf pehli baar chalega");
}, []);

// 3. Run when specific values change
useEffect(() => {
    console.log("Jab count change ho");
}, [count]);

// 4. Multiple dependencies
useEffect(() => {
    console.log("Jab count YA name change ho");
}, [count, name]);

// 5. With cleanup
useEffect(() => {
    const timer = setInterval(() => {
        console.log("Tick");
    }, 1000);
    
    // Cleanup - component unmount hone pe
    return () => clearInterval(timer);
}, []);
                </div>

                <div class="warning-box">
                    <strong>‚ö†Ô∏è Common Mistakes:</strong>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Dependency array bhoolna (infinite loop ho sakta hai)</li>
                        <li>Cleanup function na likhna (memory leaks ho sakte hain)</li>
                        <li>Async functions directly useEffect mein use karna</li>
                    </ul>
                </div>
            </div>

            <!-- Interview Questions -->
            <div class="questions-section">
                <h2 style="color: white; text-align: center; margin-bottom: 30px;">üìù Interview Questions</h2>
                
                <!-- Question 1 -->
                <div class="question-card">
                    <span class="difficulty easy">Easy</span>
                    <h4>Q1: What is the difference between Props and State in React?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(1)">Show Answer</button>
                    <div class="answer" id="answer1">
                        <strong>Answer:</strong><br><br>
                        <strong>Props:</strong>
                        <ul style="margin-left: 20px;">
                            <li>Props are <strong>immutable</strong> - component receiving props cannot modify them</li>
                            <li>Props are passed from <strong>parent to child</strong> component</li>
                            <li>Props are used to pass data and event handlers to child components</li>
                            <li>Changes in props cause component to re-render</li>
                        </ul>
                        <br>
                        <strong>State:</strong>
                        <ul style="margin-left: 20px;">
                            <li>State is <strong>mutable</strong> - component can change its own state using setState</li>
                            <li>State is <strong>local and private</strong> to the component</li>
                            <li>State is used for data that changes over time</li>
                            <li>Changes in state cause component to re-render</li>
                        </ul>
                        <br>
                        <strong>Hinglish:</strong> Props parent se aate hain aur change nahi ho sakte, jabki State component ka apna data hai jo change ho sakta hai!
                    </div>
                </div>

                <!-- Question 2 -->
                <div class="question-card">
                    <span class="difficulty easy">Easy</span>
                    <h4>Q2: Explain the concept of "Immutable Data" in React. Why can't we modify props directly?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(2)">Show Answer</button>
                    <div class="answer" id="answer2">
                        <strong>Answer:</strong><br><br>
                        Immutable data means data that cannot be changed once created. In React, props are immutable because:
                        <br><br>
                        <strong>Reasons:</strong>
                        <ul style="margin-left: 20px;">
                            <li><strong>Predictability:</strong> Makes component behavior predictable - same props always produce same output</li>
                            <li><strong>Debugging:</strong> Easier to track where data changes are coming from</li>
                            <li><strong>Performance:</strong> React can optimize rendering by doing shallow comparisons</li>
                            <li><strong>Unidirectional Data Flow:</strong> Data flows one way (parent to child), making app logic easier to understand</li>
                        </ul>
                        <br>
                        <strong>Wrong:</strong> <code>props.name = "New Name";</code> ‚ùå<br>
                        <strong>Right:</strong> Parent component should update the data and pass new props ‚úÖ
                        <br><br>
                        <strong>Hinglish:</strong> Props read-only hote hain kyunki isse app ka flow simple rehta hai aur debugging easy ho jati hai!
                    </div>
                </div>

                <!-- Question 3 -->
                <div class="question-card">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q3: What is Props Drilling and how can you solve it?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(3)">Show Answer</button>
                    <div class="answer" id="answer3">
                        <strong>Answer:</strong><br><br>
                        <strong>Props Drilling:</strong> When you need to pass data through multiple levels of components, even though intermediate components don't need that data.
                        <br><br>
                        <strong>Example:</strong><br>
                        <code>GrandParent ‚Üí Parent ‚Üí Child ‚Üí GrandChild</code><br>
                        If only GrandChild needs the data, but we have to pass it through Parent and Child.
                        <br><br>
                        <strong>Problems:</strong>
                        <ul style="margin-left: 20px;">
                            <li>Code becomes harder to maintain</li>
                            <li>Unnecessary prop passing clutters intermediate components</li>
                            <li>Refactoring becomes difficult</li>
                        </ul>
                        <br>
                        <strong>Solutions:</strong>
                        <ul style="margin-left: 20px;">
                            <li><strong>Context API:</strong> Share data without passing props explicitly</li>
                            <li><strong>Component Composition:</strong> Restructure components using children props</li>
                            <li><strong>State Management Libraries:</strong> Redux, Zustand, Recoil</li>
                            <li><strong>Custom Hooks:</strong> Encapsulate logic and state</li>
                        </ul>
                        <br>
                        <strong>Hinglish:</strong> Jab data bahut saare components se pass karna pade tab props drilling problem hoti hai. Solution: Context API ya Redux use karo!
                    </div>
                </div>

                <!-- Question 4 -->
                <div class="question-card">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q4: What are the rules of Hooks? Why do they exist?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(4)">Show Answer</button>
                    <div class="answer" id="answer4">
                        <strong>Answer:</strong><br><br>
                        <strong>Two Main Rules of Hooks:</strong>
                        <br><br>
                        <strong>1. Only Call Hooks at the Top Level</strong>
                        <ul style="margin-left: 20px;">
                            <li>Don't call Hooks inside loops, conditions, or nested functions</li>
                            <li>This ensures Hooks are called in the same order on every render</li>
                            <li><strong>Wrong:</strong> <code>if (condition) { useState(0); }</code> ‚ùå</li>
                            <li><strong>Right:</strong> Call at top level, then use condition inside ‚úÖ</li>
                        </ul>
                        <br>
                        <strong>2. Only Call Hooks from React Functions</strong>
                        <ul style="margin-left: 20px;">
                            <li>Call from React function components</li>
                            <li>Call from custom Hooks</li>
                            <li>Don't call from regular JavaScript functions</li>
                        </ul>
                        <br>
                        <strong>Why These Rules Exist:</strong><br>
                        React relies on the order in which Hooks are called to preserve state between renders. If Hook order changes, React can't match state to the correct Hook.
                        <br><br>
                        <strong>Hinglish:</strong> Hooks ko hamesha component ke top pe call karo, loops ya conditions mein nahi. Ye isliye kyunki React Hook order se state track karta hai!
                    </div>
                </div>

                <!-- Question 5 -->
                <div class="question-card">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q5: Explain useState with functional updates. When should you use them?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(5)">Show Answer</button>
                    <div class="answer" id="answer5">
                        <strong>Answer:</strong><br><br>
                        <strong>Functional Updates:</strong> When you pass a function to setState instead of a direct value.
                        <br><br>
                        <strong>Syntax:</strong><br>
                        <code>setState(prevState => newState)</code>
                        <br><br>
                        <strong>Example:</strong>
                        <pre style="background: #2d2d2d; color: #48bb78; padding: 10px; border-radius: 5px; margin: 10px 0;">
// Direct update
setCount(count + 1);

// Functional update
setCount(prevCount => prevCount + 1);
                        </pre>
                        <br>
                        <strong>When to Use Functional Updates:</strong>
                        <ul style="margin-left: 20px;">
                            <li><strong>Multiple updates in same function:</strong> Ensures each update uses latest state</li>
                            <li><strong>Inside useEffect or callbacks:</strong> Avoids stale closure issues</li>
                            <li><strong>When new state depends on previous state:</strong> Guarantees correct value</li>
                        </ul>
                        <br>
                        <strong>Example Problem:</strong>
                        <pre style="background: #2d2d2d; color: #f56565; padding: 10px; border-radius: 5px; margin: 10px 0;">
// ‚ùå This might not work as expected
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);
// Result: count + 1 (not count + 3!)

// ‚úÖ This works correctly
setCount(c => c + 1);
setCount(c => c + 1);
setCount(c => c + 1);
// Result: count + 3 ‚úì
                        </pre>
                        <br>
                        <strong>Hinglish:</strong> Jab state update previous state pe depend kare, to functional update use karo. Ye ensure karta hai ki latest state use ho!
                    </div>
                </div>

                <!-- Question 6 -->
                <div class="question-card">
                    <span class="difficulty hard">Hard</span>
                    <h4>Q6: What is the dependency array in useEffect? Explain different scenarios with examples.</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(6)">Show Answer</button>
                    <div class="answer" id="answer6">
                        <strong>Answer:</strong><br><br>
                        The dependency array controls when useEffect runs. React compares values in the array between renders.
                        <br><br>
                        <strong>Three Scenarios:</strong>
                        <br><br>
                        <strong>1. No Dependency Array:</strong>
                        <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 5px; margin: 10px 0;">
useEffect(() => {
    console.log("Runs after EVERY render");
});
// Use case: Rarely needed, usually inefficient
                        </pre>
                        <br>
                        <strong>2. Empty Dependency Array []:</strong>
                        <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 5px; margin: 10px 0;">
useEffect(() => {
    console.log("Runs ONCE on mount");
    // API calls, subscriptions, etc.
}, []);
// Use case: Component initialization, data fetching
                        </pre>
                        <br>
                        <strong>3. With Dependencies [dep1, dep2]:</strong>
                        <pre style="background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 5px; margin: 10px 0;">
useEffect(() => {
    console.log("Runs when count or name changes");
}, [count, name]);
// Use case: React to specific state/prop changes
                        </pre>
                        <br>
                        <strong>Important Rules:</strong>
                        <ul style="margin-left: 20px;">
                            <li>Include ALL values used inside effect that come from component scope</li>
                            <li>ESLint plugin helps catch missing dependencies</li>
                            <li>Objects/arrays create new references, use useCallback/useMemo if needed</li>
                        </ul>
                        <br>
                        <strong>Hinglish:</strong> Dependency array ye control karta hai ki effect kab run hoga. Empty array = sirf ek baar, with values = jab wo values change hon!
                    </div>
                </div>

                <!-- Question 7 -->
                <div class="question-card">
                    <span class="difficulty hard">Hard</span>
                    <h4>Q7: What is "Derived State" and why is it considered an anti-pattern? How should you handle it?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(7)">Show Answer</button>
                    <div class="answer" id="answer7">
                        <strong>Answer:</strong><br><br>
                        <strong>Derived State:</strong> State that can be calculated/derived from existing state or props.
                        <br><br>
                        <strong>Anti-pattern Example:</strong>
                        <pre style="background: #2d2d2d; color: #f56565; padding: 10px; border-radius: 5px; margin: 10px 0;">
// ‚ùå BAD: Unnecessary derived state
function UserList({ users }) {
    const [userCount, setUserCount] = useState(users.length);
    
    // Problem: userCount won't update when users prop changes!
    return &lt;div&gt;Total: {userCount}&lt;/div&gt;;
}
                        </pre>
                        <br>
                        <strong>Problems:</strong>
                        <ul style="margin-left: 20px;">
                            <li><strong>Sync Issues:</strong> Derived state can become out of sync with source</li>
                            <li><strong>Complexity:</strong> Need useEffect to keep things in sync</li>
                            <li><strong>Bugs:</strong> Easy to forget updating derived state</li>
                            <li><strong>Performance:</strong> Extra state means extra memory and re-renders</li>
                        </ul>
                        <br>
                        <strong>Correct Approach:</strong>
                        <pre style="background: #2d2d2d; color: #48bb78; padding: 10px; border-radius: 5px; margin: 10px 0;">
// ‚úÖ GOOD: Calculate during render
function UserList({ users }) {
    const userCount = users.length; // Direct calculation
    
    return &lt;div&gt;Total: {userCount}&lt;/div&gt;;
}

// ‚úÖ For expensive calculations, use useMemo
function UserList({ users }) {
    const sortedUsers = useMemo(() => {
        return users.sort((a, b) => a.name.localeCompare(b.name));
    }, [users]);
    
    return &lt;div&gt;{sortedUsers.length} users&lt;/div&gt;;
}
                        </pre>
                        <br>
                        <strong>Golden Rule:</strong> If you can calculate something from props/state, don't store it in state!
                        <br><br>
                        <strong>Hinglish:</strong> Jo cheez props ya state se calculate ho sakti hai, use alag state mein mat rakho. Render time pe calculate karo ya useMemo use karo!
                    </div>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="section" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;">
                <h2 style="color: white;">üéì Key Takeaways</h2>
                <ul style="font-size: 1.1em; line-height: 2;">
                    <li>‚úÖ <strong>Props</strong> are immutable and flow from parent to child</li>
                    <li>‚úÖ <strong>State</strong> is mutable and managed within a component</li>
                    <li>‚úÖ Props drilling can be solved with Context API or state management</li>
                    <li>‚úÖ Always update state correctly using setState, never mutate directly</li>
                    <li>‚úÖ React batches multiple state updates for performance</li>
                    <li>‚úÖ Avoid unnecessary derived state - calculate during render</li>
                    <li>‚úÖ <strong>useState</strong> adds state to functional components</li>
                    <li>‚úÖ <strong>useEffect</strong> handles side effects and lifecycle</li>
                    <li>‚úÖ Follow Hook rules: top level only, React functions only</li>
                    <li>‚úÖ Use functional updates when new state depends on previous state</li>
                </ul>
                <br>
                <p style="text-align: center; font-size: 1.2em; font-style: italic;">
                    "Props aate hain, State rehta hai! Hooks se sab kuch possible hai!" üöÄ
                </p>
            </div>
        </div>
    </div>

    <script>
        // Counter for local state demo
        let counter = 0;
        
        function incrementCounter() {
            counter++;
            document.getElementById('counterDisplay').textContent = counter;
        }
        
        function decrementCounter() {
            counter--;
            document.getElementById('counterDisplay').textContent = counter;
        }
        
        function resetCounter() {
            counter = 0;
            document.getElementById('counterDisplay').textContent = counter;
        }

        // Props passing demo
        function passProps() {
            document.getElementById('childData').textContent = 'Received: "Hello from Parent"';
            document.getElementById('childBox').style.background = '#48bb78';
        }
        
        function resetProps() {
            document.getElementById('childData').textContent = 'Waiting for props...';
            document.getElementById('childBox').style.background = '#764ba2';
        }

        // Items list demo
        let items = [];
        let itemCounter = 1;
        
        function addItem() {
            items = [...items, `Item ${itemCounter++}`];
            document.getElementById('items').textContent = JSON.stringify(items);
        }
        
        function clearItems() {
            items = [];
            itemCounter = 1;
            document.getElementById('items').textContent = '[]';
        }

        // useState demo
        function updateName() {
            const name = document.getElementById('nameInput').value;
            document.getElementById('nameOutput').textContent = `"${name}"`;
        }

        // useEffect demo
        let effectCounter = 0;
        let timerValue = 0;
        let timerInterval = null;
        
        function startEffect() {
            if (timerInterval) return;
            
            effectCounter++;
            document.getElementById('effectCount').textContent = effectCounter;
            
            timerInterval = setInterval(() => {
                timerValue++;
                document.getElementById('timerValue').textContent = timerValue;
            }, 1000);
        }
        
        function stopEffect() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                timerValue = 0;
                document.getElementById('timerValue').textContent = timerValue;
            }
        }

        // Toggle answer function
        function toggleAnswer(questionNumber) {
            const answer = document.getElementById(`answer${questionNumber}`);
            const button = answer.previousElementSibling;
            
            if (answer.style.display === 'none' || answer.style.display === '') {
                answer.style.display = 'block';
                button.textContent = 'Hide Answer';
                button.style.background = '#764ba2';
            } else {
                answer.style.display = 'none';
                button.textContent = 'Show Answer';
                button.style.background = '#667eea';
            }
        }
    </script>
</body>
</html>