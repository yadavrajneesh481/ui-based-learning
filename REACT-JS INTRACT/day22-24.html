<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Integration - Interactive Learning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .section h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.5em;
        }

        .definition {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }

        .definition strong {
            color: #1976D2;
        }

        .hinglish {
            background: #fff3e0;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
        }

        .demo-box {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .output {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s ease-in-out infinite;
            border-radius: 8px;
            margin: 10px 0;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-line {
            height: 20px;
            margin: 10px 0;
        }

        .skeleton-box {
            height: 100px;
            margin: 10px 0;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin: 10px 0;
            transition: border 0.3s;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .status-loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        .interview-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 50px;
        }

        .question {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .question:hover {
            transform: translateX(10px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .question h4 {
            color: #f5576c;
            margin-bottom: 10px;
        }

        .answer {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #f093fb;
        }

        .answer.show {
            display: block;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            background: #e0e0e0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .api-visualizer {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 30px;
            background: #f5f5f5;
            border-radius: 12px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .api-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 150px;
            margin: 10px;
        }

        .arrow {
            font-size: 2em;
            color: #667eea;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .code-block {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .highlight {
            color: #ffeb3b;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .content {
                padding: 20px;
            }

            .section {
                padding: 20px;
            }

            .api-visualizer {
                flex-direction: column;
            }

            .arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ API Integration Masterclass</h1>
            <p>Day 22-24: Complete Guide with Interactive Demos</p>
        </header>

        <div class="content">
            <!-- Introduction Section -->
            <div class="section">
                <h2>üìö API Integration Kya Hai?</h2>
                
                <div class="definition">
                    <strong>API (Application Programming Interface):</strong> A set of rules and protocols that allows different software applications to communicate with each other.
                </div>

                <div class="hinglish">
                    <p><strong>Simple shabdon mein:</strong> API ek waiter ki tarah hai jo aapke order (request) ko kitchen (server) tak le jaata hai aur phir khana (response) wapas laata hai. Jaise aap restaurant mein directly kitchen mein nahi jaate, waise hi aapka application directly database ya server se baat nahi karta - API ke through karta hai!</p>
                </div>

                <div class="api-visualizer">
                    <div class="api-box">
                        <h3>üñ•Ô∏è Client</h3>
                        <p>Your App</p>
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="api-box">
                        <h3>üîå API</h3>
                        <p>Middleware</p>
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="api-box">
                        <h3>üíæ Server</h3>
                        <p>Database</p>
                    </div>
                </div>
            </div>

            <!-- Fetch API Section -->
            <div class="section">
                <h2>1Ô∏è‚É£ Fetch API</h2>

                <div class="definition">
                    <strong>Fetch API:</strong> A modern, promise-based JavaScript API for making HTTP requests to servers. It provides a cleaner and more powerful way to make network requests compared to older methods like XMLHttpRequest.
                </div>

                <div class="hinglish">
                    <p><strong>Samjho aise:</strong> Fetch API JavaScript ka built-in tarika hai server se data mangne ka. Ye promises use karta hai, matlab asynchronous hai - aapka code wait nahi karta, baaki kaam karta rehta hai jab tak response nahi aata.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Fetch API</h3>
                    <div class="tabs">
                        <button class="tab active" onclick="switchTab('fetch-get')">GET Request</button>
                        <button class="tab" onclick="switchTab('fetch-post')">POST Request</button>
                        <button class="tab" onclick="switchTab('fetch-error')">Error Handling</button>
                    </div>

                    <div id="fetch-get" class="tab-content active">
                        <p><strong>GET Request:</strong> Server se data fetch karne ke liye</p>
                        <button class="btn" onclick="fetchGetDemo()">Fetch User Data</button>
                        <button class="btn btn-danger" onclick="clearOutput('fetch-output')">Clear</button>
                        <div id="fetch-output" class="output">Output yahan dikhega...</div>
                    </div>

                    <div id="fetch-post" class="tab-content">
                        <p><strong>POST Request:</strong> Server ko naya data bhejne ke liye</p>
                        <input type="text" id="post-title" placeholder="Enter title">
                        <input type="text" id="post-body" placeholder="Enter body">
                        <button class="btn btn-success" onclick="fetchPostDemo()">Create Post</button>
                        <div id="post-output" class="output">Output yahan dikhega...</div>
                    </div>

                    <div id="fetch-error" class="tab-content">
                        <p><strong>Error Handling:</strong> Jab API fail ho jaye</p>
                        <button class="btn btn-warning" onclick="fetchErrorDemo()">Trigger Error</button>
                        <div id="error-output" class="output">Output yahan dikhega...</div>
                    </div>
                </div>

                <div class="code-block">
<span class="highlight">// Basic Fetch Syntax</span>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

<span class="highlight">// With async/await (Modern approach)</span>
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
                </div>
            </div>

            <!-- HTTP Methods Section -->
            <div class="section">
                <h2>2Ô∏è‚É£ HTTP Methods (CRUD Operations)</h2>

                <div class="hinglish">
                    <p><strong>Ye 4 main methods hain:</strong> GET (data lao), POST (naya data banao), PUT (data update karo), DELETE (data hatao). Isko CRUD operations bhi kehte hain - Create, Read, Update, Delete.</p>
                </div>

                <div class="grid">
                    <div class="card">
                        <h3>üì• GET</h3>
                        <p><strong>Purpose:</strong> Retrieve data</p>
                        <p>Server se data fetch karta hai</p>
                        <span class="status status-success">Read Only</span>
                    </div>
                    <div class="card">
                        <h3>üì§ POST</h3>
                        <p><strong>Purpose:</strong> Create new data</p>
                        <p>Naya data server pe bhejta hai</p>
                        <span class="status status-success">Creates New</span>
                    </div>
                    <div class="card">
                        <h3>‚úèÔ∏è PUT</h3>
                        <p><strong>Purpose:</strong> Update existing data</p>
                        <p>Purane data ko update karta hai</p>
                        <span class="status status-loading">Modifies</span>
                    </div>
                    <div class="card">
                        <h3>üóëÔ∏è DELETE</h3>
                        <p><strong>Purpose:</strong> Remove data</p>
                        <p>Data ko delete karta hai</p>
                        <span class="status status-error">Removes</span>
                    </div>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: All HTTP Methods</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn" onclick="httpGetDemo()">GET</button>
                        <button class="btn btn-success" onclick="httpPostDemo()">POST</button>
                        <button class="btn btn-warning" onclick="httpPutDemo()">PUT</button>
                        <button class="btn btn-danger" onclick="httpDeleteDemo()">DELETE</button>
                    </div>
                    <div id="http-output" class="output">Output yahan dikhega...</div>
                </div>
            </div>

            <!-- Loading States Section -->
            <div class="section">
                <h2>3Ô∏è‚É£ Loading States & Skeleton UI</h2>

                <div class="definition">
                    <strong>Loading State:</strong> A visual indicator that shows the user that content is being fetched or processed, improving user experience by providing feedback during asynchronous operations.
                </div>

                <div class="hinglish">
                    <p><strong>Kyun zaroori hai?</strong> Jab API call hoti hai, user ko pata hona chahiye ki kuch ho raha hai. Loading state dikhane se user experience better hota hai. Skeleton UI ek modern approach hai jahan actual content ki shape dikhate hain loading ke time.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Loading States</h3>
                    <button class="btn" onclick="showLoadingDemo()">Show Loading Spinner</button>
                    <button class="btn btn-success" onclick="showSkeletonDemo()">Show Skeleton UI</button>
                    <button class="btn btn-danger" onclick="clearLoading()">Clear</button>
                    
                    <div id="loading-demo" style="margin-top: 20px;"></div>
                </div>

                <div class="code-block">
<span class="highlight">// Loading State Implementation</span>
async function fetchWithLoading() {
  const loadingEl = document.getElementById('loading');
  loadingEl.style.display = 'block'; // Show loading
  
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    // Process data
  } catch (error) {
    console.error(error);
  } finally {
    loadingEl.style.display = 'none'; // Hide loading
  }
}
                </div>
            </div>

            <!-- Error Handling Section -->
            <div class="section">
                <h2>4Ô∏è‚É£ Error Handling & Retry Patterns</h2>

                <div class="definition">
                    <strong>Error Handling:</strong> The process of anticipating, detecting, and resolving errors that occur during API calls, ensuring the application remains stable and provides meaningful feedback to users.
                </div>

                <div class="hinglish">
                    <p><strong>Real life mein:</strong> API calls kabhi kabhi fail ho sakti hain - network issue, server down, wrong URL, etc. Achhe developer hamesha error handling karte hain. Retry pattern matlab agar ek baar fail ho jaye toh automatically dobara try karo.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Retry Pattern</h3>
                    <p>Ye demo 3 baar try karega agar API fail ho jaye</p>
                    <input type="number" id="retry-count" placeholder="Max retries (default: 3)" min="1" max="5" value="3">
                    <button class="btn" onclick="retryDemo()">Test Retry Pattern</button>
                    <div id="retry-output" class="output">Output yahan dikhega...</div>
                    <div class="progress-bar">
                        <div id="retry-progress" class="progress-fill" style="width: 0%">0%</div>
                    </div>
                </div>

                <div class="code-block">
<span class="highlight">// Retry Pattern Implementation</span>
async function fetchWithRetry(url, options = {}, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return await response.json();
    } catch (error) {
      if (i === retries - 1) throw error;
      console.log(`Retry ${i + 1}/${retries}...`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
                </div>
            </div>

            <!-- AbortController Section -->
            <div class="section">
                <h2>5Ô∏è‚É£ AbortController - Request Cancel Karna</h2>

                <div class="definition">
                    <strong>AbortController:</strong> A Web API that allows you to abort one or more fetch requests programmatically, useful for canceling ongoing requests when they're no longer needed.
                </div>

                <div class="hinglish">
                    <p><strong>Use case:</strong> Maan lo user ne search kiya, API call start hui, lekin user ne turant search term change kar diya. Ab purani API call ki zaroorat nahi hai. AbortController se hum usko cancel kar sakte hain. Ye performance improve karta hai aur unnecessary requests bachata hai.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: AbortController</h3>
                    <p>Start a long request and cancel it before completion</p>
                    <button class="btn" onclick="startAbortDemo()" id="start-abort">Start Long Request (10s)</button>
                    <button class="btn btn-danger" onclick="cancelRequest()" id="cancel-abort" disabled>Cancel Request</button>
                    <div id="abort-output" class="output">Output yahan dikhega...</div>
                </div>

                <div class="code-block">
<span class="highlight">// AbortController Usage</span>
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request cancelled!');
    }
  });

// Cancel the request
controller.abort();
                </div>
            </div>

            <!-- Debounced Search Section -->
            <div class="section">
                <h2>6Ô∏è‚É£ Debounced API Search</h2>

                <div class="definition">
                    <strong>Debouncing:</strong> A programming technique that delays the execution of a function until after a certain amount of time has passed since it was last called, reducing the number of times a function is executed.
                </div>

                <div class="hinglish">
                    <p><strong>Problem:</strong> Agar user search box mein type kar raha hai, har keystroke pe API call karoge toh bahut saari unnecessary calls ho jayengi. <strong>Solution:</strong> Debouncing - user typing khatam karne ke baad (jaise 500ms wait karke) API call karo. Ye bandwidth bachata hai aur performance improve karta hai.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Debounced Search</h3>
                    <p>Type karo aur dekho - API call 500ms ke baad hogi</p>
                    <input type="text" id="search-input" placeholder="Search users... (try typing 'john')">
                    <div id="search-status" style="margin: 10px 0;"></div>
                    <div id="search-results" class="output">Results yahan dikhenge...</div>
                </div>

                <div class="code-block">
<span class="highlight">// Debounce Function</span>
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// Usage
const searchAPI = debounce(async (query) => {
  const response = await fetch(`/api/search?q=${query}`);
  const data = await response.json();
  displayResults(data);
}, 500);

input.addEventListener('input', (e) => searchAPI(e.target.value));
                </div>
            </div>

            <!-- Multiple API Calls Section -->
            <div class="section">
                <h2>7Ô∏è‚É£ Multiple API Calls Handle Karna</h2>

                <div class="definition">
                    <strong>Promise.all():</strong> A method that takes an array of promises and returns a single promise that resolves when all input promises have resolved, or rejects if any promise rejects.
                </div>

                <div class="hinglish">
                    <p><strong>Scenario:</strong> Kabhi kabhi aapko ek saath multiple APIs call karni padti hain. Teen tarike hain: <strong>Sequential</strong> (ek ke baad ek), <strong>Parallel</strong> (sab ek saath), aur <strong>Race</strong> (jo pehle aaye usko use karo). Promise.all() sabse common hai parallel calls ke liye.</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Multiple API Calls</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn" onclick="sequentialDemo()">Sequential (Slow)</button>
                        <button class="btn btn-success" onclick="parallelDemo()">Parallel (Fast)</button>
                        <button class="btn btn-warning" onclick="raceDemo()">Race (First Wins)</button>
                    </div>
                    <div id="multiple-output" class="output">Output yahan dikhega...</div>
                </div>

                <div class="code-block">
<span class="highlight">// Sequential (One after another)</span>
const user = await fetch('/api/user/1').then(r => r.json());
const posts = await fetch('/api/posts/1').then(r => r.json());
const comments = await fetch('/api/comments/1').then(r => r.json());

<span class="highlight">// Parallel (All at once - FASTER!)</span>
const [user, posts, comments] = await Promise.all([
  fetch('/api/user/1').then(r => r.json()),
  fetch('/api/posts/1').then(r => r.json()),
  fetch('/api/comments/1').then(r => r.json())
]);

<span class="highlight">// Race (First one wins)</span>
const fastest = await Promise.race([
  fetch('/api/server1/data'),
  fetch('/api/server2/data'),
  fetch('/api/server3/data')
]);
                </div>
            </div>

            <!-- Polling Section -->
            <div class="section">
                <h2>8Ô∏è‚É£ Real-time Updates & Polling</h2>

                <div class="definition">
                    <strong>Polling:</strong> A technique where the client repeatedly requests data from the server at regular intervals to check for updates, simulating real-time behavior.
                </div>

                <div class="hinglish">
                    <p><strong>Kab use karein?</strong> Jab aapko real-time updates chahiye ho - jaise stock prices, notifications, live scores. Polling matlab har kuch seconds mein API call karke check karo ki koi naya data hai ya nahi. Dhyan rahe - zyada frequent polling server pe load badha sakti hai!</p>
                </div>

                <div class="demo-box">
                    <h3>üéØ Live Demo: Polling</h3>
                    <p>Har 3 seconds mein random data fetch hoga</p>
                    <button class="btn" onclick="startPolling()" id="start-poll">Start Polling</button>
                    <button class="btn btn-danger" onclick="stopPolling()" id="stop-poll" disabled>Stop Polling</button>
                    <div id="poll-output" class="output">Polling start karo...</div>
                    <div style="margin-top: 10px;">
                        <strong>Poll Count:</strong> <span id="poll-count">0</span>
                    </div>
                </div>

                <div class="code-block">
<span class="highlight">// Simple Polling Implementation</span>
let pollingInterval;

function startPolling(url, interval = 3000) {
  pollingInterval = setInterval(async () => {
    try {
      const response = await fetch(url);
      const data = await response.json();
      updateUI(data);
    } catch (error) {
      console.error('Polling error:', error);
    }
  }, interval);
}

function stopPolling() {
  clearInterval(pollingInterval);
}
                </div>
            </div>

            <!-- Interview Questions Section -->
            <div class="interview-section">
                <h2>üéØ Interview Questions (Basic to Advanced)</h2>
                <p style="margin-bottom: 20px;">Click on each question to reveal the answer</p>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q1. Fetch API aur XMLHttpRequest mein kya difference hai? (Basic)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Fetch API:</strong> Modern, promise-based, cleaner syntax, returns Response object</li>
                            <li><strong>XMLHttpRequest:</strong> Older, callback-based, more verbose, complex error handling</li>
                            <li><strong>Key Difference:</strong> Fetch doesn't reject on HTTP errors (404, 500) - you need to check response.ok</li>
                            <li><strong>Hinglish:</strong> Fetch modern hai aur use karna easy hai. XMLHttpRequest purana tarika hai jo callbacks use karta tha.</li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q2. CORS error kya hai aur kaise solve karein? (Intermediate)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>CORS (Cross-Origin Resource Sharing):</strong> Browser security feature that blocks requests to different domains</li>
                            <li><strong>Error:</strong> "Access to fetch has been blocked by CORS policy"</li>
                            <li><strong>Solutions:</strong>
                                <ul>
                                    <li>Backend pe CORS headers enable karo (Access-Control-Allow-Origin)</li>
                                    <li>Proxy server use karo (development mein)</li>
                                    <li>JSONP use karo (old method, not recommended)</li>
                                </ul>
                            </li>
                            <li><strong>Hinglish:</strong> CORS ek security feature hai. Agar aap different domain se API call kar rahe ho toh server ko explicitly allow karna padta hai.</li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q3. Debouncing aur Throttling mein kya fark hai? (Intermediate)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Debouncing:</strong> Function execute hota hai jab user action stop kar de (after delay)
                                <br>Example: Search box - user typing band kare tab API call
                            </li>
                            <li><strong>Throttling:</strong> Function execute hota hai at regular intervals, chahe user action continue ho
                                <br>Example: Scroll event - har 200ms mein ek baar execute
                            </li>
                            <li><strong>Hinglish:</strong> Debouncing = "Ruk jao, phir karo", Throttling = "Thoda thoda karke karo"</li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q4. Promise.all() aur Promise.race() mein difference explain karo with use cases (Advanced)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Promise.all():</strong>
                                <ul>
                                    <li>Waits for ALL promises to resolve</li>
                                    <li>Agar ek bhi fail ho toh pura fail</li>
                                    <li>Use case: Jab sabhi data chahiye ho (user + posts + comments)</li>
                                </ul>
                            </li>
                            <li><strong>Promise.race():</strong>
                                <ul>
                                    <li>Returns jab FIRST promise resolve/reject ho</li>
                                    <li>Baaki promises ignore ho jate hain</li>
                                    <li>Use case: Multiple servers se fastest response chahiye, timeout implementation</li>
                                </ul>
                            </li>
                            <li><strong>Promise.allSettled():</strong> Sabka wait karta hai, failures ko bhi handle karta hai (bonus!)</li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q5. API retry logic implement karte waqt exponential backoff kyun use karte hain? (Advanced)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Exponential Backoff:</strong> Har retry ke baad wait time exponentially increase hota hai (1s, 2s, 4s, 8s...)</li>
                            <li><strong>Why?</strong>
                                <ul>
                                    <li>Server ko recover hone ka time milta hai</li>
                                    <li>Network congestion kam hota hai</li>
                                    <li>Prevents "thundering herd" problem</li>
                                </ul>
                            </li>
                            <li><strong>Formula:</strong> delay = baseDelay * (2 ^ attemptNumber)</li>
                            <li><strong>Hinglish:</strong> Agar server down hai toh turant dobara request bhejne se aur problem hogi. Thoda wait karo, phir try karo. Har baar wait time badhao.</li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q6. AbortController ka real-world use case explain karo (Advanced)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Use Cases:</strong>
                                <ul>
                                    <li><strong>Search Autocomplete:</strong> User typing ke time purani requests cancel karo</li>
                                    <li><strong>Component Unmount:</strong> React/Vue mein component unmount hone pe pending requests cancel karo (memory leak prevention)</li>
                                    <li><strong>Timeout Implementation:</strong> Agar API 5 seconds mein respond nahi kare toh cancel karo</li>
                                    <li><strong>User Navigation:</strong> User dusre page pe chala gaya toh current page ki requests cancel karo</li>
                                </ul>
                            </li>
                            <li><strong>Code Example:</strong>
                                <pre style="background: #1e1e1e; padding: 10px; border-radius: 5px; margin-top: 10px;">
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000); // 5s timeout

fetch(url, { signal: controller.signal })
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Request timeout!');
    }
  });
                                </pre>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="question" onclick="toggleAnswer(this)">
                    <h4>Q7. Polling vs WebSockets vs Server-Sent Events - kab kya use karein? (Expert)</h4>
                    <div class="answer">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Polling:</strong>
                                <ul>
                                    <li>Simple implementation, works everywhere</li>
                                    <li>Use: Jab updates frequently nahi chahiye (every 30s+)</li>
                                    <li>Cons: Inefficient, server load zyada</li>
                                </ul>
                            </li>
                            <li><strong>WebSockets:</strong>
                                <ul>
                                    <li>Full-duplex, bidirectional communication</li>
                                    <li>Use: Chat apps, multiplayer games, collaborative editing</li>
                                    <li>Cons: Complex setup, requires WebSocket server</li>
                                </ul>
                            </li>
                            <li><strong>Server-Sent Events (SSE):</strong>
                                <ul>
                                    <li>One-way communication (server to client)</li>
                                    <li>Use: Live feeds, notifications, stock tickers</li>
                                    <li>Cons: Only server can push, not bidirectional</li>
                                </ul>
                            </li>
                            <li><strong>Decision Tree:</strong>
                                <ul>
                                    <li>Need bidirectional? ‚Üí WebSockets</li>
                                    <li>Only server pushes? ‚Üí SSE</li>
                                    <li>Simple updates? ‚Üí Polling</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="section" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;">
                <h2>üìù Quick Summary</h2>
                <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                    <ul style="list-style: none; padding: 0;">
                        <li>‚úÖ <strong>Fetch API:</strong> Modern way to make HTTP requests</li>
                        <li>‚úÖ <strong>HTTP Methods:</strong> GET, POST, PUT, DELETE for CRUD operations</li>
                        <li>‚úÖ <strong>Error Handling:</strong> Always use try-catch and retry patterns</li>
                        <li>‚úÖ <strong>Loading States:</strong> Better UX with spinners and skeleton UI</li>
                        <li>‚úÖ <strong>AbortController:</strong> Cancel unnecessary requests</li>
                        <li>‚úÖ <strong>Debouncing:</strong> Optimize search and input events</li>
                        <li>‚úÖ <strong>Multiple Calls:</strong> Use Promise.all() for parallel execution</li>
                        <li>‚úÖ <strong>Polling:</strong> Regular intervals for real-time updates</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let abortController = null;
        let pollingInterval = null;
        let pollCount = 0;
        let searchTimeout = null;

        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }

        // Clear output
        function clearOutput(id) {
            document.getElementById(id).textContent = 'Output cleared...';
        }

        // Fetch GET Demo
        async function fetchGetDemo() {
            const output = document.getElementById('fetch-output');
            output.innerHTML = '<div class="loading"></div> Loading...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
                const data = await response.json();
                
                output.textContent = JSON.stringify(data, null, 2);
                output.innerHTML += '\n\n‚úÖ Success! User data fetched.';
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        // Fetch POST Demo
        async function fetchPostDemo() {
            const title = document.getElementById('post-title').value;
            const body = document.getElementById('post-body').value;
            const output = document.getElementById('post-output');
            
            if (!title || !body) {
                output.textContent = '‚ö†Ô∏è Please fill both fields!';
                return;
            }
            
            output.innerHTML = '<div class="loading"></div> Creating post...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: title,
                        body: body,
                        userId: 1
                    })
                });
                
                const data = await response.json();
                output.textContent = JSON.stringify(data, null, 2);
                output.innerHTML += '\n\n‚úÖ Post created successfully!';
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        // Fetch Error Demo
        async function fetchErrorDemo() {
            const output = document.getElementById('error-output');
            output.innerHTML = '<div class="loading"></div> Attempting to fetch from invalid URL...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/invalid-endpoint-404');
                
                if (!response.ok) {
                    throw new Error(`HTTP Error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                output.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                output.textContent = `‚ùå Error Caught!\n\nError Type: ${error.name}\nError Message: ${error.message}\n\nüí° Tip: Always check response.ok before parsing JSON!`;
            }
        }

        // HTTP Methods Demo
        async function httpGetDemo() {
            const output = document.getElementById('http-output');
            output.innerHTML = '<div class="loading"></div> GET Request...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
                const data = await response.json();
                output.textContent = `GET Request Success!\n\n${JSON.stringify(data, null, 2)}`;
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        async function httpPostDemo() {
            const output = document.getElementById('http-output');
            output.innerHTML = '<div class="loading"></div> POST Request...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: 'New Post', body: 'Content', userId: 1 })
                });
                const data = await response.json();
                output.textContent = `POST Request Success!\n\n${JSON.stringify(data, null, 2)}`;
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        async function httpPutDemo() {
            const output = document.getElementById('http-output');
            output.innerHTML = '<div class="loading"></div> PUT Request...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: 1, title: 'Updated', body: 'Updated content', userId: 1 })
                });
                const data = await response.json();
                output.textContent = `PUT Request Success!\n\n${JSON.stringify(data, null, 2)}`;
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        async function httpDeleteDemo() {
            const output = document.getElementById('http-output');
            output.innerHTML = '<div class="loading"></div> DELETE Request...';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1', {
                    method: 'DELETE'
                });
                output.textContent = `DELETE Request Success!\n\nStatus: ${response.status}\nPost deleted successfully!`;
            } catch (error) {
                output.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        // Loading States Demo
        function showLoadingDemo() {
            const demo = document.getElementById('loading-demo');
            demo.innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <div class="loading" style="width: 50px; height: 50px; border-width: 5px;"></div>
                    <p style="margin-top: 20px;">Loading data...</p>
                </div>
            `;
            
            setTimeout(() => {
                demo.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: green;">
                        <h3>‚úÖ Data Loaded Successfully!</h3>
                        <p>This is how you show loading states</p>
                    </div>
                `;
            }, 2000);
        }

        function showSkeletonDemo() {
            const demo = document.getElementById('loading-demo');
            demo.innerHTML = `
                <div style="padding: 20px;">
                    <div class="skeleton skeleton-line"></div>
                    <div class="skeleton skeleton-line" style="width: 80%;"></div>
                    <div class="skeleton skeleton-line" style="width: 60%;"></div>
                    <div class="skeleton skeleton-box"></div>
                    <div class="skeleton skeleton-line" style="width: 90%;"></div>
                </div>
            `;
            
            setTimeout(() => {
                demo.innerHTML = `
                    <div style="padding: 20px;">
                        <h3>Real Content Loaded!</h3>
                        <p>This is actual content that replaced the skeleton UI.</p>
                        <div style="background: #f0f0f0; padding: 20px; border-radius: 8px; margin: 10px 0;">
                            <p>Skeleton UI provides better user experience than simple loading spinners because it shows the structure of the content that's loading.</p>
                        </div>
                        <p>Users perceive skeleton screens as faster loading!</p>
                    </div>
                `;
            }, 2000);
        }

        function clearLoading() {
            document.getElementById('loading-demo').innerHTML = '';
        }

        // Retry Pattern Demo
        async function retryDemo() {
            const output = document.getElementById('retry-output');
            const progress = document.getElementById('retry-progress');
            const maxRetries = parseInt(document.getElementById('retry-count').value) || 3;
            
            output.textContent = 'Starting retry pattern demo...\n\n';
            progress.style.width = '0%';
            progress.textContent = '0%';
            
            for (let i = 1; i <= maxRetries; i++) {
                output.textContent += `Attempt ${i}/${maxRetries}...\n`;
                
                const progressPercent = (i / maxRetries) * 100;
                progress.style.width = progressPercent + '%';
                progress.textContent = Math.round(progressPercent) + '%';
                
                try {
                    // Simulating API call with random success/failure
                    await new Promise((resolve, reject) => {
                        setTimeout(() => {
                            if (Math.random() > 0.5 || i === maxRetries) {
                                resolve();
                            } else {
                                reject(new Error('Network error'));
                            }
                        }, 1000);
                    });
                    
                    output.textContent += `‚úÖ Success on attempt ${i}!\n\n`;
                    output.textContent += `Total attempts: ${i}\n`;
                    output.textContent += `Success rate: ${((1/i) * 100).toFixed(2)}%`;
                    break;
                } catch (error) {
                    output.textContent += `‚ùå Failed: ${error.message}\n`;
                    if (i < maxRetries) {
                        const delay = 1000 * i; // Exponential backoff
                        output.textContent += `Waiting ${delay}ms before retry...\n\n`;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        output.textContent += `\n‚ùå All ${maxRetries} attempts failed!`;
                    }
                }
            }
        }

        // AbortController Demo
        async function startAbortDemo() {
            const output = document.getElementById('abort-output');
            const startBtn = document.getElementById('start-abort');
            const cancelBtn = document.getElementById('cancel-abort');
            
            abortController = new AbortController();
            
            startBtn.disabled = true;
            cancelBtn.disabled = false;
            
            output.textContent = 'Starting long request (10 seconds)...\n';
            output.textContent += 'You can cancel it anytime!\n\n';
            
            try {
                // Simulating a long request
                const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                    signal: abortController.signal
                });
                
                // Simulate delay
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(resolve, 10000);
                    abortController.signal.addEventListener('abort', () => {
                        clearTimeout(timeout);
                        reject(new DOMException('Request cancelled', 'AbortError'));
                    });
                });
                
                const data = await response.json();
                output.textContent += '‚úÖ Request completed successfully!\n';
                output.textContent += `Received ${data.length} items`;
            } catch (error) {
                if (error.name === 'AbortError') {
                    output.textContent += 'üõë Request cancelled by user!\n';
                    output.textContent += 'This is how you prevent unnecessary API calls.';
                } else {
                    output.textContent += `‚ùå Error: ${error.message}`;
                }
            } finally {
                startBtn.disabled = false;
                cancelBtn.disabled = true;
            }
        }

        function cancelRequest() {
            if (abortController) {
                abortController.abort();
            }
        }

        // Debounced Search Demo
        document.getElementById('search-input')?.addEventListener('input', function(e) {
            const query = e.target.value;
            const status = document.getElementById('search-status');
            const results = document.getElementById('search-results');
            
            // Clear previous timeout
            clearTimeout(searchTimeout);
            
            if (!query) {
                results.textContent = 'Results yahan dikhenge...';
                status.textContent = '';
                return;
            }
            
            status.innerHTML = '<span class="status status-loading">‚è≥ Typing...</span>';
            
            // Debounce: Wait 500ms after user stops typing
            searchTimeout = setTimeout(async () => {
                status.innerHTML = '<span class="status status-loading"><div class="loading"></div> Searching...</span>';
                
                try {
                    const response = await fetch(`https://jsonplaceholder.typicode.com/users?name_like=${query}`);
                    const data = await response.json();
                    
                    status.innerHTML = '<span class="status status-success">‚úÖ Search complete</span>';
                    
                    if (data.length > 0) {
                        results.textContent = `Found ${data.length} results:\n\n`;
                        results.textContent += JSON.stringify(data, null, 2);
                    } else {
                        results.textContent = 'No results found. Try searching for "Leanne" or "Ervin"';
                    }
                } catch (error) {
                    status.innerHTML = '<span class="status status-error">‚ùå Error</span>';
                    results.textContent = `Error: ${error.message}`;
                }
            }, 500);
        });

        // Multiple API Calls Demo
        async function sequentialDemo() {
            const output = document.getElementById('multiple-output');
            output.textContent = 'Sequential calls (one after another)...\n\n';
            
            const startTime = Date.now();
            
            try {
                output.textContent += '1Ô∏è‚É£ Fetching users...\n';
                const users = await fetch('https://jsonplaceholder.typicode.com/users/1').then(r => r.json());
                output.textContent += `‚úÖ Got user: ${users.name}\n\n`;
                
                output.textContent += '2Ô∏è‚É£ Fetching posts...\n';
                const posts = await fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.json());
                output.textContent += `‚úÖ Got post: ${posts.title}\n\n`;
                
                output.textContent += '3Ô∏è‚É£ Fetching comments...\n';
                const comments = await fetch('https://jsonplaceholder.typicode.com/comments/1').then(r => r.json());
                output.textContent += `‚úÖ Got comment from: ${comments.email}\n\n`;
                
                const endTime = Date.now();
                output.textContent += `‚è±Ô∏è Total time: ${endTime - startTime}ms\n`;
                output.textContent += '‚ö†Ô∏è Slow because each waits for previous!';
            } catch (error) {
                output.textContent += `‚ùå Error: ${error.message}`;
            }
        }

        async function parallelDemo() {
            const output = document.getElementById('multiple-output');
            output.textContent = 'Parallel calls (all at once)...\n\n';
            
            const startTime = Date.now();
            
            try {
                output.textContent += 'üöÄ Fetching all data simultaneously...\n\n';
                
                const [users, posts, comments] = await Promise.all([
                    fetch('https://jsonplaceholder.typicode.com/users/1').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/comments/1').then(r => r.json())
                ]);
                
                output.textContent += `‚úÖ User: ${users.name}\n`;
                output.textContent += `‚úÖ Post: ${posts.title}\n`;
                output.textContent += `‚úÖ Comment: ${comments.email}\n\n`;
                
                const endTime = Date.now();
                output.textContent += `‚è±Ô∏è Total time: ${endTime - startTime}ms\n`;
                output.textContent += '‚ö° Much faster! All requests ran in parallel!';
            } catch (error) {
                output.textContent += `‚ùå Error: ${error.message}`;
            }
        }

        async function raceDemo() {
            const output = document.getElementById('multiple-output');
            output.textContent = 'Race condition (first one wins)...\n\n';
            
            const startTime = Date.now();
            
            try {
                output.textContent += 'üèÅ Racing 3 API calls...\n\n';
                
                const winner = await Promise.race([
                    fetch('https://jsonplaceholder.typicode.com/users/1').then(r => r.json()).then(d => ({source: 'Users API', data: d})),
                    fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.json()).then(d => ({source: 'Posts API', data: d})),
                    fetch('https://jsonplaceholder.typicode.com/comments/1').then(r => r.json()).then(d => ({source: 'Comments API', data: d}))
                ]);
                
                const endTime = Date.now();
                
                output.textContent += `üèÜ Winner: ${winner.source}\n\n`;
                output.textContent += `Data: ${JSON.stringify(winner.data, null, 2)}\n\n`;
                output.textContent += `‚è±Ô∏è Time: ${endTime - startTime}ms\n`;
                output.textContent += 'üí° Only the fastest response is used!';
            } catch (error) {
                output.textContent += `‚ùå Error: ${error.message}`;
            }
        }

        // Polling Demo
        function startPolling() {
            const output = document.getElementById('poll-output');
            const startBtn = document.getElementById('start-poll');
            const stopBtn = document.getElementById('stop-poll');
            const countEl = document.getElementById('poll-count');
            
            pollCount = 0;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            output.textContent = 'Polling started...\n\n';
            
            pollingInterval = setInterval(async () => {
                pollCount++;
                countEl.textContent = pollCount;
                
                try {
                    // Simulating real-time data
                    const randomId = Math.floor(Math.random() * 10) + 1;
                    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${randomId}`);
                    const data = await response.json();
                    
                    output.textContent = `Poll #${pollCount} at ${new Date().toLocaleTimeString()}\n\n`;
                    output.textContent += `Random Post ID: ${data.id}\n`;
                    output.textContent += `Title: ${data.title}\n\n`;
                    output.textContent += '‚è∞ Next poll in 3 seconds...';
                } catch (error) {
                    output.textContent += `\n‚ùå Error: ${error.message}`;
                }
            }, 3000);
        }

        function stopPolling() {
            clearInterval(pollingInterval);
            document.getElementById('start-poll').disabled = false;
            document.getElementById('stop-poll').disabled = true;
            document.getElementById('poll-output').textContent += '\n\nüõë Polling stopped!';
        }

        // Toggle Interview Answers
        function toggleAnswer(element) {
            const answer = element.querySelector('.answer');
            answer.classList.toggle('show');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (pollingInterval) clearInterval(pollingInterval);
            if (abortController) abortController.abort();
        });
    </script>
</body>
</html>