<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Component Lifecycle - Interactive Learning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .section h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.5em;
        }

        .hinglish {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .technical {
            background: #d1ecf1;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #17a2b8;
            font-family: 'Courier New', monospace;
        }

        .lifecycle-demo {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .lifecycle-stages {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }

        .stage {
            flex: 1;
            min-width: 200px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .stage:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .stage.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            transform: scale(1.05);
        }

        .demo-component {
            background: #e9ecef;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .demo-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #333;
        }

        .useEffect-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .effect-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .effect-card h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .keyword { color: #c678dd; }
        .function { color: #61afef; }
        .string { color: #98c379; }
        .comment { color: #5c6370; font-style: italic; }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        .quiz-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 50px;
        }

        .quiz-section h2 {
            color: white;
            margin-bottom: 30px;
        }

        .question {
            background: white;
            color: #333;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .question h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .difficulty {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .difficulty.easy { background: #d4edda; color: #155724; }
        .difficulty.medium { background: #fff3cd; color: #856404; }
        .difficulty.hard { background: #f8d7da; color: #721c24; }

        .toggle-answer {
            margin-top: 15px;
            padding: 8px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .answer {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .answer.show {
            display: block;
        }

        .counter-display {
            font-size: 3em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .dependency-demo {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .dependency-card {
            flex: 1;
            min-width: 250px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .content {
                padding: 20px;
            }

            .section {
                padding: 20px;
            }

            .lifecycle-stages {
                flex-direction: column;
            }
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        .warning {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #f5c6cb;
        }

        .tip {
            background: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #bee5eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîÑ React Component Lifecycle</h1>
            <p>Class Components se Hooks tak ka safar - Interactive Learning</p>
        </header>

        <div class="content">
            <!-- Section 1: Class Lifecycle Methods -->
            <div class="section">
                <h2>üìö Class Lifecycle Methods</h2>
                
                <div class="hinglish">
                    <strong>Samjhiye:</strong> Purane zamane mein React mein class components use hote the, aur har component ki ek "life" hoti thi - birth (mounting), growth (updating), aur death (unmounting). Har stage pe kuch special methods call hote the jinhe hum <span class="highlight">lifecycle methods</span> kehte hain.
                </div>

                <div class="technical">
                    <strong>Technical Definition:</strong> Lifecycle methods are special methods in class components that get automatically invoked at specific phases of a component's existence in the React component tree.
                </div>

                <h3>üé≠ Interactive Lifecycle Demo</h3>
                <div class="lifecycle-demo">
                    <div class="lifecycle-stages">
                        <div class="stage" data-stage="mounting">
                            <h3>üå± Mounting</h3>
                            <p>Birth</p>
                        </div>
                        <div class="stage" data-stage="updating">
                            <h3>üîÑ Updating</h3>
                            <p>Growth</p>
                        </div>
                        <div class="stage" data-stage="unmounting">
                            <h3>üíÄ Unmounting</h3>
                            <p>Death</p>
                        </div>
                    </div>

                    <div class="demo-component">
                        <h3>Component Status: <span id="componentStatus">Not Mounted</span></h3>
                        <div class="counter-display" id="counterDisplay">0</div>
                        <div class="demo-controls">
                            <button class="btn-primary" onclick="mountComponent()">Mount Component</button>
                            <button class="btn-success" onclick="updateComponent()">Update Component</button>
                            <button class="btn-danger" onclick="unmountComponent()">Unmount Component</button>
                        </div>
                    </div>

                    <div class="log-container" id="lifecycleLog">
                        <div class="log-entry">üìã Lifecycle logs will appear here...</div>
                    </div>
                </div>

                <div class="hinglish">
                    <strong>Dekho kya ho raha hai:</strong> Jab aap "Mount" button dabate ho, component DOM mein add hota hai. "Update" se component re-render hota hai, aur "Unmount" se component DOM se hata diya jata hai. Har action pe different lifecycle methods call hote hain!
                </div>

                <h3>üìä Class Lifecycle Methods Table</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Method</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td rowspan="4"><strong>Mounting</strong></td>
                            <td>constructor()</td>
                            <td>Initialize state aur bind methods</td>
                        </tr>
                        <tr>
                            <td>static getDerivedStateFromProps()</td>
                            <td>Props se state derive karna</td>
                        </tr>
                        <tr>
                            <td>render()</td>
                            <td>JSX return karna</td>
                        </tr>
                        <tr>
                            <td>componentDidMount()</td>
                            <td>API calls, subscriptions setup</td>
                        </tr>
                        <tr>
                            <td rowspan="5"><strong>Updating</strong></td>
                            <td>static getDerivedStateFromProps()</td>
                            <td>Props changes handle karna</td>
                        </tr>
                        <tr>
                            <td>shouldComponentUpdate()</td>
                            <td>Re-render control karna</td>
                        </tr>
                        <tr>
                            <td>render()</td>
                            <td>Updated JSX return karna</td>
                        </tr>
                        <tr>
                            <td>getSnapshotBeforeUpdate()</td>
                            <td>DOM update se pehle info capture karna</td>
                        </tr>
                        <tr>
                            <td>componentDidUpdate()</td>
                            <td>DOM updates ke baad operations</td>
                        </tr>
                        <tr>
                            <td><strong>Unmounting</strong></td>
                            <td>componentWillUnmount()</td>
                            <td>Cleanup: timers, subscriptions cancel</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
<span class="keyword">class</span> <span class="function">MyComponent</span> <span class="keyword">extends</span> React.Component {
  <span class="function">constructor</span>(props) {
    <span class="keyword">super</span>(props);
    <span class="keyword">this</span>.state = { count: <span class="string">0</span> };
    <span class="comment">// 1Ô∏è‚É£ Sabse pehle yeh call hota hai</span>
  }

  <span class="function">componentDidMount</span>() {
    <span class="comment">// 2Ô∏è‚É£ Component DOM mein add hone ke baad</span>
    <span class="comment">// Yahan API calls karo</span>
    console.log(<span class="string">'Component mounted!'</span>);
  }

  <span class="function">componentDidUpdate</span>(prevProps, prevState) {
    <span class="comment">// 3Ô∏è‚É£ Jab bhi component update ho</span>
    <span class="keyword">if</span> (prevState.count !== <span class="keyword">this</span>.state.count) {
      console.log(<span class="string">'Count changed!'</span>);
    }
  }

  <span class="function">componentWillUnmount</span>() {
    <span class="comment">// 4Ô∏è‚É£ Component remove hone se pehle</span>
    <span class="comment">// Cleanup karo: timers, subscriptions</span>
    console.log(<span class="string">'Component will unmount!'</span>);
  }

  <span class="function">render</span>() {
    <span class="keyword">return</span> <span class="string">&lt;div&gt;{this.state.count}&lt;/div&gt;</span>;
  }
}
                </div>
            </div>

            <!-- Section 2: Why Lifecycle Changed -->
            <div class="section">
                <h2>üîÑ Why Lifecycle Changed in React 16+</h2>

                <div class="hinglish">
                    <strong>Kahani:</strong> React 16 mein ek bada change aaya - <span class="highlight">Fiber Architecture</span>. Isse React ko rendering ko chhote pieces mein todne ki power mili. Lekin purane lifecycle methods iske saath compatible nahi the, kyunki kuch methods multiple times call ho sakte the ya beech mein pause ho sakte the!
                </div>

                <div class="technical">
                    <strong>Technical Definition:</strong> React Fiber introduced asynchronous rendering, making some lifecycle methods unsafe because they could be called multiple times or interrupted mid-execution, leading to bugs and inconsistent behavior.
                </div>

                <h3>‚ö†Ô∏è Deprecated Methods (Ab use mat karo!)</h3>
                <div class="warning">
                    <strong>Ye methods ab UNSAFE hain:</strong>
                    <ul>
                        <li>‚ùå componentWillMount() ‚Üí UNSAFE_componentWillMount()</li>
                        <li>‚ùå componentWillReceiveProps() ‚Üí UNSAFE_componentWillReceiveProps()</li>
                        <li>‚ùå componentWillUpdate() ‚Üí UNSAFE_componentWillUpdate()</li>
                    </ul>
                    <p><strong>Kyun?</strong> Kyunki Fiber architecture mein ye methods multiple times call ho sakte hain, jisse side effects duplicate ho sakte hain!</p>
                </div>

                <h3>‚úÖ New Safe Alternatives</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Old (Unsafe)</th>
                            <th>New (Safe)</th>
                            <th>Reason</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>componentWillMount</td>
                            <td>constructor / componentDidMount</td>
                            <td>Side effects ko mount ke baad karo</td>
                        </tr>
                        <tr>
                            <td>componentWillReceiveProps</td>
                            <td>getDerivedStateFromProps</td>
                            <td>Pure function, no side effects</td>
                        </tr>
                        <tr>
                            <td>componentWillUpdate</td>
                            <td>getSnapshotBeforeUpdate</td>
                            <td>DOM info capture karne ke liye</td>
                        </tr>
                    </tbody>
                </table>

                <div class="tip">
                    <strong>üí° Pro Tip:</strong> Modern React mein, class components ki jagah <strong>Hooks</strong> use karo! Hooks zyada simple aur powerful hain. useEffect hook sabhi lifecycle methods ko replace kar sakta hai!
                </div>
            </div>

            <!-- Section 3: Deep Dive into useEffect -->
            <div class="section">
                <h2>üé£ Deep Dive into useEffect</h2>

                <div class="hinglish">
                    <strong>useEffect kya hai?</strong> Ye ek React Hook hai jo functional components mein side effects handle karta hai. Side effects matlab - API calls, subscriptions, timers, DOM manipulation, etc. Ye class components ke <span class="highlight">componentDidMount</span>, <span class="highlight">componentDidUpdate</span>, aur <span class="highlight">componentWillUnmount</span> ka combined replacement hai!
                </div>

                <div class="technical">
                    <strong>Technical Definition:</strong> useEffect is a Hook that lets you perform side effects in functional components. It runs after every render by default, but can be controlled with dependency arrays.
                </div>

                <h3>üéÆ Interactive useEffect Demo</h3>
                <div class="useEffect-demo">
                    <div class="effect-card">
                        <h4>1Ô∏è‚É£ No Dependencies (Har render pe)</h4>
                        <div class="counter-display" id="noDepsCounter">0</div>
                        <button class="btn-primary" onclick="incrementNoDeps()">Increment</button>
                        <p style="margin-top: 10px; font-size: 0.9em;">Effect runs: <strong id="noDepsRuns">0</strong> times</p>
                    </div>

                    <div class="effect-card">
                        <h4>2Ô∏è‚É£ Empty Dependencies (Sirf mount pe)</h4>
                        <div class="counter-display" id="emptyDepsCounter">0</div>
                        <button class="btn-primary" onclick="incrementEmptyDeps()">Increment</button>
                        <p style="margin-top: 10px; font-size: 0.9em;">Effect runs: <strong id="emptyDepsRuns">0</strong> times</p>
                    </div>

                    <div class="effect-card">
                        <h4>3Ô∏è‚É£ With Dependencies</h4>
                        <input type="text" id="nameInput" placeholder="Type your name..." oninput="handleNameChange()">
                        <p style="margin-top: 10px; font-size: 0.9em;">Effect runs: <strong id="depsRuns">0</strong> times</p>
                    </div>
                </div>

                <div class="hinglish">
                    <strong>Dekho difference:</strong>
                    <ul>
                        <li><strong>No Dependencies:</strong> Har baar component render ho, effect chalega</li>
                        <li><strong>Empty Array []:</strong> Sirf pehli baar (mount pe) effect chalega</li>
                        <li><strong>With Dependencies [name]:</strong> Jab 'name' change ho, tab effect chalega</li>
                    </ul>
                </div>

                <h3>üìù useEffect Syntax Variations</h3>
                <div class="code-block">
<span class="comment">// 1Ô∏è‚É£ Har render pe chalta hai (dangerous!)</span>
<span class="function">useEffect</span>(() => {
  console.log(<span class="string">'Runs after every render'</span>);
});

<span class="comment">// 2Ô∏è‚É£ Sirf mount pe chalta hai (componentDidMount)</span>
<span class="function">useEffect</span>(() => {
  console.log(<span class="string">'Runs only once on mount'</span>);
}, []); <span class="comment">// Empty dependency array</span>

<span class="comment">// 3Ô∏è‚É£ Jab dependencies change hon (componentDidUpdate)</span>
<span class="function">useEffect</span>(() => {
  console.log(<span class="string">'Runs when count changes'</span>);
}, [count]); <span class="comment">// Dependency array with count</span>

<span class="comment">// 4Ô∏è‚É£ Cleanup function ke saath (componentWillUnmount)</span>
<span class="function">useEffect</span>(() => {
  <span class="keyword">const</span> timer = <span class="function">setInterval</span>(() => {
    console.log(<span class="string">'Tick'</span>);
  }, <span class="string">1000</span>);

  <span class="comment">// Cleanup function - unmount pe ya next effect se pehle</span>
  <span class="keyword">return</span> () => {
    <span class="function">clearInterval</span>(timer);
    console.log(<span class="string">'Cleanup done!'</span>);
  };
}, []);
                </div>

                <h3>üßπ Cleanup Function</h3>
                <div class="hinglish">
                    <strong>Cleanup kyun zaroori hai?</strong> Imagine karo tumne ek timer start kiya, ya kisi API se subscription li. Agar component unmount ho jaye aur tum cleanup nahi karo, toh timer chalta rahega aur memory leak ho jayega! Cleanup function isi problem ko solve karta hai.
                </div>

                <div class="lifecycle-demo">
                    <h4>Timer Demo with Cleanup</h4>
                    <div class="demo-component">
                        <h3>Timer: <span id="timerDisplay">0</span>s</h3>
                        <div class="demo-controls">
                            <button class="btn-primary" onclick="startTimer()">Start Timer</button>
                            <button class="btn-danger" onclick="stopTimer()">Stop Timer (Cleanup)</button>
                        </div>
                    </div>
                    <div class="log-container" id="timerLog">
                        <div class="log-entry">‚è±Ô∏è Timer logs will appear here...</div>
                    </div>
                </div>

                <div class="code-block">
<span class="keyword">function</span> <span class="function">TimerComponent</span>() {
  <span class="keyword">const</span> [seconds, setSeconds] = <span class="function">useState</span>(<span class="string">0</span>);

  <span class="function">useEffect</span>(() => {
    console.log(<span class="string">'‚è∞ Timer started!'</span>);
    
    <span class="keyword">const</span> interval = <span class="function">setInterval</span>(() => {
      <span class="function">setSeconds</span>(prev => prev + <span class="string">1</span>);
    }, <span class="string">1000</span>);

    <span class="comment">// üßπ Cleanup function</span>
    <span class="keyword">return</span> () => {
      <span class="function">clearInterval</span>(interval);
      console.log(<span class="string">'üõë Timer stopped and cleaned up!'</span>);
    };
  }, []); <span class="comment">// Empty array = sirf mount/unmount pe</span>

  <span class="keyword">return</span> <span class="string">&lt;div&gt;Seconds: {seconds}&lt;/div&gt;</span>;
}
                </div>

                <h3>ü™§ Dependency Array Traps</h3>
                <div class="warning">
                    <strong>‚ö†Ô∏è Common Mistakes:</strong>
                    <ol>
                        <li><strong>Missing Dependencies:</strong> Dependency array mein wo sab values dalo jo effect ke andar use ho rahi hain</li>
                        <li><strong>Object/Array Dependencies:</strong> Objects aur arrays har render pe naye bante hain, infinite loop ho sakta hai!</li>
                        <li><strong>Functions in Dependencies:</strong> Functions bhi har render pe naye bante hain</li>
                    </ol>
                </div>

                <div class="code-block">
<span class="comment">// ‚ùå WRONG: Missing dependency</span>
<span class="function">useEffect</span>(() => {
  console.log(count); <span class="comment">// 'count' use ho raha hai</span>
}, []); <span class="comment">// But dependency array mein nahi hai!</span>

<span class="comment">// ‚úÖ CORRECT: Include all dependencies</span>
<span class="function">useEffect</span>(() => {
  console.log(count);
}, [count]); <span class="comment">// 'count' dependency array mein hai</span>

<span class="comment">// ‚ùå WRONG: Object dependency (infinite loop!)</span>
<span class="keyword">const</span> user = { name: <span class="string">'John'</span> }; <span class="comment">// Har render pe naya object</span>
<span class="function">useEffect</span>(() => {
  console.log(user.name);
}, [user]); <span class="comment">// Infinite loop!</span>

<span class="comment">// ‚úÖ CORRECT: Use primitive values</span>
<span class="keyword">const</span> user = { name: <span class="string">'John'</span> };
<span class="function">useEffect</span>(() => {
  console.log(user.name);
}, [user.name]); <span class="comment">// Sirf name track karo</span>
                </div>

                <h3>‚ôæÔ∏è Avoiding Infinite Loops</h3>
                <div class="hinglish">
                    <strong>Infinite loop kab hota hai?</strong> Jab tumhara effect kuch aisa change kare jo khud effect ko trigger kare! Example: effect mein state update karo, aur wo state dependency array mein ho, aur koi condition na ho.
                </div>

                <div class="lifecycle-demo">
                    <h4>Infinite Loop Demo (Controlled)</h4>
                    <div class="demo-component">
                        <p>Loop Counter: <span id="loopCounter">0</span></p>
                        <div class="demo-controls">
                            <button class="btn-danger" onclick="triggerInfiniteLoop()">‚ö†Ô∏è Trigger Loop (Will Stop at 10)</button>
                            <button class="btn-success" onclick="resetLoop()">Reset</button>
                        </div>
                    </div>
                    <div class="log-container" id="loopLog">
                        <div class="log-entry">üîÑ Loop logs will appear here...</div>
                    </div>
                </div>

                <div class="code-block">
<span class="comment">// ‚ùå INFINITE LOOP!</span>
<span class="keyword">function</span> <span class="function">BadComponent</span>() {
  <span class="keyword">const</span> [count, setCount] = <span class="function">useState</span>(<span class="string">0</span>);

  <span class="function">useEffect</span>(() => {
    <span class="function">setCount</span>(count + <span class="string">1</span>); <span class="comment">// State update</span>
  }, [count]); <span class="comment">// count dependency mein hai!</span>
  
  <span class="comment">// Effect runs ‚Üí count changes ‚Üí effect runs ‚Üí count changes ‚Üí ‚ôæÔ∏è</span>
}

<span class="comment">// ‚úÖ CORRECT: Add condition</span>
<span class="keyword">function</span> <span class="function">GoodComponent</span>() {
  <span class="keyword">const</span> [count, setCount] = <span class="function">useState</span>(<span class="string">0</span>);

  <span class="function">useEffect</span>(() => {
    <span class="keyword">if</span> (count < <span class="string">10</span>) { <span class="comment">// Condition add karo!</span>
      <span class="function">setCount</span>(count + <span class="string">1</span>);
    }
  }, [count]);
}
                </div>

                <h3>üåê Fetching Data Inside useEffect</h3>
                <div class="hinglish">
                    <strong>API calls kaise karein?</strong> useEffect ke andar async function directly nahi likh sakte, kyunki useEffect ko synchronous function chahiye. Toh andar ek async function banao aur use call karo!
                </div>

                <div class="lifecycle-demo">
                    <h4>Data Fetching Demo</h4>
                    <div class="demo-component">
                        <input type="number" id="userIdInput" placeholder="Enter User ID (1-10)" min="1" max="10" value="1">
                        <button class="btn-primary" onclick="fetchUserData()" style="margin-top: 10px;">Fetch User</button>
                        <div id="userData" style="margin-top: 20px; text-align: left;"></div>
                    </div>
                </div>

                <div class="code-block">
<span class="comment">// ‚ùå WRONG: useEffect can't be async directly</span>
<span class="function">useEffect</span>(<span class="keyword">async</span> () => {
  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/data'</span>);
}, []); <span class="comment">// Error!</span>

<span class="comment">// ‚úÖ CORRECT: Create async function inside</span>
<span class="function">useEffect</span>(() => {
  <span class="keyword">const</span> <span class="function">fetchData</span> = <span class="keyword">async</span> () => {
    <span class="keyword">try</span> {
      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/data'</span>);
      <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="function">json</span>();
      <span class="function">setData</span>(data);
    } <span class="keyword">catch</span> (error) {
      console.<span class="function">error</span>(<span class="string">'Error:'</span>, error);
    }
  };

  <span class="function">fetchData</span>(); <span class="comment">// Call the async function</span>
}, []); <span class="comment">// Empty array = fetch only once</span>

<span class="comment">// ‚úÖ BETTER: With cleanup for race conditions</span>
<span class="function">useEffect</span>(() => {
  <span class="keyword">let</span> cancelled = <span class="keyword">false</span>; <span class="comment">// Flag for cleanup</span>

  <span class="keyword">const</span> <span class="function">fetchData</span> = <span class="keyword">async</span> () => {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/data'</span>);
    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="function">json</span>();
    
    <span class="keyword">if</span> (!cancelled) { <span class="comment">// Only update if not cancelled</span>
      <span class="function">setData</span>(data);
    }
  };

  <span class="function">fetchData</span>();

  <span class="keyword">return</span> () => {
    cancelled = <span class="keyword">true</span>; <span class="comment">// Cleanup: mark as cancelled</span>
  };
}, []);
                </div>

                <h3>‚ö° useEffect vs useLayoutEffect</h3>
                <div class="hinglish">
                    <strong>Difference kya hai?</strong> Dono almost same hain, bas timing different hai:
                    <ul>
                        <li><strong>useEffect:</strong> Browser ke paint hone ke <em>baad</em> chalta hai (asynchronous)</li>
                        <li><strong>useLayoutEffect:</strong> Browser ke paint hone se <em>pehle</em> chalta hai (synchronous)</li>
                    </ul>
                </div>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>useEffect</th>
                            <th>useLayoutEffect</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Timing</td>
                            <td>After browser paint</td>
                            <td>Before browser paint</td>
                        </tr>
                        <tr>
                            <td>Blocking</td>
                            <td>Non-blocking (async)</td>
                            <td>Blocking (sync)</td>
                        </tr>
                        <tr>
                            <td>Use Case</td>
                            <td>API calls, subscriptions, most side effects</td>
                            <td>DOM measurements, preventing visual flicker</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Better (doesn't block paint)</td>
                            <td>Can slow down if heavy operations</td>
                        </tr>
                        <tr>
                            <td>When to Use</td>
                            <td>99% of the time (default choice)</td>
                            <td>Only when you need to read/write DOM before paint</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
<span class="comment">// useEffect - Runs AFTER paint (user sees old value briefly)</span>
<span class="keyword">function</span> <span class="function">EffectExample</span>() {
  <span class="keyword">const</span> [width, setWidth] = <span class="function">useState</span>(<span class="string">0</span>);
  <span class="keyword">const</span> divRef = <span class="function">useRef</span>();

  <span class="function">useEffect</span>(() => {
    <span class="function">setWidth</span>(divRef.current.offsetWidth);
  }, []);

  <span class="keyword">return</span> <span class="string">&lt;div ref={divRef}&gt;Width: {width}&lt;/div&gt;</span>;
  <span class="comment">// User might see "Width: 0" briefly, then correct width</span>
}

<span class="comment">// useLayoutEffect - Runs BEFORE paint (no flicker)</span>
<span class="keyword">function</span> <span class="function">LayoutEffectExample</span>() {
  <span class="keyword">const</span> [width, setWidth] = <span class="function">useState</span>(<span class="string">0</span>);
  <span class="keyword">const</span> divRef = <span class="function">useRef</span>();

  <span class="function">useLayoutEffect</span>(() => {
    <span class="function">setWidth</span>(divRef.current.offsetWidth);
  }, []);

  <span class="keyword">return</span> <span class="string">&lt;div ref={divRef}&gt;Width: {width}&lt;/div&gt;</span>;
  <span class="comment">// User sees correct width immediately, no flicker</span>
}
                </div>

                <div class="tip">
                    <strong>üí° Rule of Thumb:</strong> Hamesha <strong>useEffect</strong> use karo. Sirf tab <strong>useLayoutEffect</strong> use karo jab:
                    <ul>
                        <li>DOM measurements leni ho (scrollHeight, offsetWidth, etc.)</li>
                        <li>Visual flicker prevent karni ho</li>
                        <li>DOM ko paint se pehle modify karna ho</li>
                    </ul>
                </div>

                <h3>üíâ useInsertionEffect</h3>
                <div class="hinglish">
                    <strong>Ye kya hai?</strong> Ye React 18 mein aaya hai aur ye <em>sabse pehle</em> chalta hai - DOM mutations se bhi pehle! Lekin ye sirf CSS-in-JS libraries ke liye hai (jaise styled-components, emotion). Normal developers ko iska use nahi karna chahiye!
                </div>

                <div class="technical">
                    <strong>Technical Definition:</strong> useInsertionEffect fires synchronously before all DOM mutations, primarily designed for CSS-in-JS libraries to inject styles before layout effects read them.
                </div>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Hook</th>
                            <th>Execution Order</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>useInsertionEffect</td>
                            <td>1Ô∏è‚É£ First (before DOM mutations)</td>
                            <td>CSS-in-JS libraries only</td>
                        </tr>
                        <tr>
                            <td>useLayoutEffect</td>
                            <td>2Ô∏è‚É£ Second (before browser paint)</td>
                            <td>DOM measurements, preventing flicker</td>
                        </tr>
                        <tr>
                            <td>useEffect</td>
                            <td>3Ô∏è‚É£ Third (after browser paint)</td>
                            <td>Most side effects (API calls, subscriptions)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
<span class="comment">// useInsertionEffect - CSS-in-JS libraries ke liye</span>
<span class="keyword">function</span> <span class="function">useCSS</span>(rule) {
  <span class="function">useInsertionEffect</span>(() => {
    <span class="comment">// Inject CSS before any layout effects run</span>
    <span class="keyword">const</span> style = document.<span class="function">createElement</span>(<span class="string">'style'</span>);
    style.textContent = rule;
    document.head.<span class="function">appendChild</span>(style);
    
    <span class="keyword">return</span> () => {
      document.head.<span class="function">removeChild</span>(style);
    };
  }, [rule]);
}

<span class="comment">// ‚ö†Ô∏è Normal developers: DON'T use this!</span>
<span class="comment">// Use useEffect or useLayoutEffect instead</span>
                </div>

                <div class="warning">
                    <strong>‚ö†Ô∏è Warning:</strong> useInsertionEffect ko normal development mein use mat karo! Ye sirf library authors ke liye hai. Agar tumhe DOM manipulation chahiye, use <strong>useLayoutEffect</strong>. Agar normal side effects chahiye, use <strong>useEffect</strong>.
                </div>
            </div>

            <!-- Quiz Section -->
            <div class="quiz-section">
                <h2>üéØ Interview Questions</h2>
                <p style="margin-bottom: 30px;">Apni understanding test karo! Click karke answers dekho.</p>

                <div class="question">
                    <span class="difficulty easy">Easy</span>
                    <h4>Q1: What are the three main phases of a React component lifecycle?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(1)">Show Answer</button>
                    <div class="answer" id="answer1">
                        <strong>Answer:</strong> The three main phases are:
                        <ol>
                            <li><strong>Mounting:</strong> Jab component DOM mein add hota hai (birth)</li>
                            <li><strong>Updating:</strong> Jab component re-render hota hai due to state/props changes (growth)</li>
                            <li><strong>Unmounting:</strong> Jab component DOM se remove hota hai (death)</li>
                        </ol>
                        <p><strong>Hinglish:</strong> Component ki life teen stages mein hoti hai - paida hona (mounting), bada hona (updating), aur marna (unmounting).</p>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty easy">Easy</span>
                    <h4>Q2: What is the purpose of the cleanup function in useEffect?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(2)">Show Answer</button>
                    <div class="answer" id="answer2">
                        <strong>Answer:</strong> The cleanup function is used to:
                        <ul>
                            <li>Cancel subscriptions</li>
                            <li>Clear timers (setTimeout, setInterval)</li>
                            <li>Remove event listeners</li>
                            <li>Abort API requests</li>
                            <li>Prevent memory leaks</li>
                        </ul>
                        <p><strong>Hinglish:</strong> Cleanup function ka kaam hai safai karna - timers band karna, subscriptions cancel karna, taaki memory leak na ho. Ye component unmount hone se pehle ya next effect run hone se pehle chalta hai.</p>
                        <pre style="background: #282c34; color: #abb2bf; padding: 10px; border-radius: 5px; margin-top: 10px;">
useEffect(() => {
  const timer = setInterval(() => console.log('tick'), 1000);
  
  return () => clearInterval(timer); // Cleanup!
}, []);
                        </pre>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q3: Why were componentWillMount, componentWillReceiveProps, and componentWillUpdate marked as UNSAFE in React 16+?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(3)">Show Answer</button>
                    <div class="answer" id="answer3">
                        <strong>Answer:</strong> These methods were marked UNSAFE because of React's new Fiber architecture:
                        <ul>
                            <li><strong>Fiber enables asynchronous rendering</strong> - React can pause, abort, or restart rendering</li>
                            <li><strong>These methods can be called multiple times</strong> before a single render completes</li>
                            <li><strong>Side effects in these methods</strong> (API calls, subscriptions) can execute multiple times, causing bugs</li>
                            <li><strong>They're not "pure"</strong> - they can have side effects that don't work well with interruption</li>
                        </ul>
                        <p><strong>Hinglish:</strong> React 16 mein Fiber architecture aaya jo rendering ko chhote pieces mein tod sakta hai. Purane "Will" methods beech mein multiple times call ho sakte the, jisse side effects duplicate ho jate the. Isliye inhe UNSAFE mark kar diya aur naye safe alternatives diye gaye.</p>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q4: What's the difference between useEffect with an empty dependency array [] and no dependency array at all?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(4)">Show Answer</button>
                    <div class="answer" id="answer4">
                        <strong>Answer:</strong>
                        <table style="width: 100%; margin-top: 10px; background: white; border-collapse: collapse;">
                            <tr style="background: #667eea; color: white;">
                                <th style="padding: 10px; text-align: left;">Scenario</th>
                                <th style="padding: 10px; text-align: left;">When Effect Runs</th>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border-bottom: 1px solid #ddd;"><code>useEffect(() => {...})</code></td>
                                <td style="padding: 10px; border-bottom: 1px solid #ddd;">After EVERY render (dangerous!)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px;"><code>useEffect(() => {...}, [])</code></td>
                                <td style="padding: 10px;">Only ONCE on mount (like componentDidMount)</td>
                            </tr>
                        </table>
                        <p style="margin-top: 10px;"><strong>Hinglish:</strong> Bina dependency array ke effect har render pe chalta hai (bahut dangerous!). Empty array [] ke saath sirf pehli baar mount pe chalta hai. Hamesha dependency array use karo!</p>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty medium">Medium</span>
                    <h4>Q5: How do you prevent infinite loops when using useEffect?</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(5)">Show Answer</button>
                    <div class="answer" id="answer5">
                        <strong>Answer:</strong> Infinite loops ko prevent karne ke liye:
                        <ol>
                            <li><strong>Always use dependency array</strong> - bina array ke har render pe chalega</li>
                            <li><strong>Add conditions</strong> - state update se pehle condition check karo</li>
                            <li><strong>Use primitive values in dependencies</strong> - objects/arrays har render pe naye bante hain</li>
                            <li><strong>Use useCallback/useMemo</strong> - functions aur objects ko memoize karo</li>
                            <li><strong>Don't update dependency inside effect</strong> - jo dependency hai use effect ke andar update mat karo (bina condition ke)</li>
                        </ol>
                        <pre style="background: #282c34; color: #abb2bf; padding: 10px; border-radius: 5px; margin-top: 10px;">
// ‚ùå Infinite loop
useEffect(() => {
  setCount(count + 1);
}, [count]);

// ‚úÖ Fixed with condition
useEffect(() => {
  if (count < 10) {
    setCount(count + 1);
  }
}, [count]);

// ‚úÖ Better: use functional update
useEffect(() => {
  setCount(prev => prev < 10 ? prev + 1 : prev);
}, []); // No dependency on count!
                        </pre>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty hard">Hard</span>
                    <h4>Q6: When should you use useLayoutEffect instead of useEffect? Provide a real-world example.</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(6)">Show Answer</button>
                    <div class="answer" id="answer6">
                        <strong>Answer:</strong> Use useLayoutEffect when you need to:
                        <ul>
                            <li><strong>Read DOM measurements</strong> (scrollHeight, offsetWidth, getBoundingClientRect)</li>
                            <li><strong>Prevent visual flicker</strong> by updating DOM before paint</li>
                            <li><strong>Synchronously re-render</strong> based on DOM measurements</li>
                        </ul>
                        <p><strong>Real-world example:</strong> Tooltip positioning</p>
                        <pre style="background: #282c34; color: #abb2bf; padding: 10px; border-radius: 5px; margin-top: 10px;">
function Tooltip({ targetRef, children }) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef();

  useLayoutEffect(() => {
    // Measure target element
    const targetRect = targetRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    
    // Calculate position to avoid overflow
    const top = targetRect.bottom + 10;
    const left = targetRect.left - (tooltipRect.width / 2);
    
    setPosition({ top, left });
  }, [targetRef]);

  return (
    &lt;div ref={tooltipRef} style={{ position: 'absolute', ...position }}&gt;
      {children}
    &lt;/div&gt;
  );
}
// useLayoutEffect ensures tooltip appears at correct position
// immediately, without flickering at wrong position first
                        </pre>
                        <p><strong>Hinglish:</strong> useLayoutEffect tab use karo jab DOM ko measure karna ho aur uske basis pe turant update karna ho, taaki user ko flicker na dikhe. Tooltip, dropdown positioning, scroll animations - yahan use hota hai.</p>
                    </div>
                </div>

                <div class="question">
                    <span class="difficulty hard">Hard</span>
                    <h4>Q7: Explain the race condition problem when fetching data in useEffect and how to solve it.</h4>
                    <button class="toggle-answer" onclick="toggleAnswer(7)">Show Answer</button>
                    <div class="answer" id="answer7">
                        <strong>Answer:</strong> Race condition tab hota hai jab:
                        <ul>
                            <li>User quickly changes input (e.g., search query)</li>
                            <li>Multiple API requests fire in sequence</li>
                            <li>Responses arrive in different order than requests</li>
                            <li>Older response arrives last and overwrites newer data</li>
                        </ul>
                        <p><strong>Solution: Use cleanup function with cancellation flag</strong></p>
                        <pre style="background: #282c34; color: #abb2bf; padding: 10px; border-radius: 5px; margin-top: 10px;">
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    let cancelled = false; // Cancellation flag

    async function fetchResults() {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();
      
      // Only update if this effect hasn't been cleaned up
      if (!cancelled) {
        setResults(data);
      }
    }

    fetchResults();

    // Cleanup: mark this request as cancelled
    return () => {
      cancelled = true;
    };
  }, [query]);

  return &lt;div&gt;{results.map(...)}&lt;/div&gt;;
}

// Better: Use AbortController (modern approach)
useEffect(() => {
  const controller = new AbortController();

  fetch(`/api/search?q=${query}`, { signal: controller.signal })
    .then(res => res.json())
    .then(data => setResults(data))
    .catch(err => {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    });

  return () => controller.abort(); // Cancel request
}, [query]);
                        </pre>
                        <p><strong>Hinglish:</strong> Race condition ka matlab hai ki purani request ka response baad mein aa jaye aur nayi data ko overwrite kar de. Solution: cleanup function mein ek flag set karo ya AbortController use karke request cancel karo.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Lifecycle Demo Variables
        let isMounted = false;
        let componentCounter = 0;
        let logCounter = 0;

        // Timer Demo Variables
        let timerInterval = null;
        let timerSeconds = 0;

        // useEffect Demo Variables
        let noDepsCounter = 0;
        let noDepsRuns = 0;
        let emptyDepsCounter = 0;
        let emptyDepsRuns = 0;
        let depsRuns = 0;

        // Loop Demo Variables
        let loopCounter = 0;
        let loopInterval = null;

        // Lifecycle Stage Highlighting
        document.querySelectorAll('.stage').forEach(stage => {
            stage.addEventListener('click', function() {
                document.querySelectorAll('.stage').forEach(s => s.classList.remove('active'));
                this.classList.add('active');
                
                const stageName = this.dataset.stage;
                addLog(`üìç Exploring ${stageName} phase`);
            });
        });

        function addLog(message) {
            const logContainer = document.getElementById('lifecycleLog');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function mountComponent() {
            if (isMounted) {
                addLog('‚ö†Ô∏è Component already mounted!');
                return;
            }
            
            isMounted = true;
            document.getElementById('componentStatus').textContent = 'Mounted ‚úÖ';
            
            addLog('üå± constructor() called');
            addLog('üå± getDerivedStateFromProps() called');
            addLog('üå± render() called');
            addLog('üå± componentDidMount() called');
            addLog('‚úÖ Component successfully mounted!');
        }

        function updateComponent() {
            if (!isMounted) {
                addLog('‚ö†Ô∏è Mount component first!');
                return;
            }
            
            componentCounter++;
            document.getElementById('counterDisplay').textContent = componentCounter;
            document.getElementById('componentStatus').textContent = 'Updated üîÑ';
            
            addLog('üîÑ getDerivedStateFromProps() called');
            addLog('üîÑ shouldComponentUpdate() returned true');
            addLog('üîÑ render() called');
            addLog('üîÑ getSnapshotBeforeUpdate() called');
            addLog('üîÑ componentDidUpdate() called');
            addLog('‚úÖ Component updated!');
            
            setTimeout(() => {
                document.getElementById('componentStatus').textContent = 'Mounted ‚úÖ';
            }, 1000);
        }

        function unmountComponent() {
            if (!isMounted) {
                addLog('‚ö†Ô∏è Component not mounted!');
                return;
            }
            
            isMounted = false;
            componentCounter = 0;
            document.getElementById('counterDisplay').textContent = '0';
            document.getElementById('componentStatus').textContent = 'Unmounted üíÄ';
            
            addLog('üíÄ componentWillUnmount() called');
            addLog('üíÄ Cleanup: clearing timers, subscriptions');
            addLog('‚úÖ Component unmounted!');
            
            setTimeout(() => {
                document.getElementById('componentStatus').textContent = 'Not Mounted';
            }, 2000);
        }

        // Timer Demo Functions
        function startTimer() {
            if (timerInterval) {
                addTimerLog('‚ö†Ô∏è Timer already running!');
                return;
            }
            
            timerSeconds = 0;
            document.getElementById('timerDisplay').textContent = timerSeconds;
            addTimerLog('‚è∞ Timer started (useEffect called)');
            addTimerLog('üìù setInterval created');
            
            timerInterval = setInterval(() => {
                timerSeconds++;
                document.getElementById('timerDisplay').textContent = timerSeconds;
                addTimerLog(`‚è±Ô∏è Tick: ${timerSeconds}s`);
            }, 1000);
        }

        function stopTimer() {
            if (!timerInterval) {
                addTimerLog('‚ö†Ô∏è Timer not running!');
                return;
            }
            
            clearInterval(timerInterval);
            timerInterval = null;
            addTimerLog('üßπ Cleanup function called');
            addTimerLog('üõë clearInterval executed');
            addTimerLog('‚úÖ Timer stopped and cleaned up!');
        }

        function addTimerLog(message) {
            const logContainer = document.getElementById('timerLog');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // useEffect Demo Functions
        function incrementNoDeps() {
            noDepsCounter++;
            noDepsRuns++;
            document.getElementById('noDepsCounter').textContent = noDepsCounter;
            document.getElementById('noDepsRuns').textContent = noDepsRuns;
        }

        function incrementEmptyDeps() {
            emptyDepsCounter++;
            if (emptyDepsRuns === 0) {
                emptyDepsRuns = 1;
                document.getElementById('emptyDepsRuns').textContent = emptyDepsRuns;
            }
            document.getElementById('emptyDepsCounter').textContent = emptyDepsCounter;
        }

        function handleNameChange() {
            depsRuns++;
            document.getElementById('depsRuns').textContent = depsRuns;
        }

        // Infinite Loop Demo
        function triggerInfiniteLoop() {
            if (loopInterval) {
                addLoopLog('‚ö†Ô∏è Loop already running!');
                return;
            }
            
            loopCounter = 0;
            document.getElementById('loopCounter').textContent = loopCounter;
            addLoopLog('üîÑ Starting controlled infinite loop...');
            addLoopLog('‚ö†Ô∏è Without condition, this would crash!');
            
            loopInterval = setInterval(() => {
                loopCounter++;
                document.getElementById('loopCounter').textContent = loopCounter;
                addLoopLog(`üîÑ Loop iteration: ${loopCounter}`);
                
                if (loopCounter >= 10) {
                    clearInterval(loopInterval);
                    loopInterval = null;
                    addLoopLog('‚úÖ Stopped at 10 (condition saved us!)');
                    addLoopLog('üí° Always add conditions to prevent infinite loops!');
                }
            }, 300);
        }

        function resetLoop() {
            if (loopInterval) {
                clearInterval(loopInterval);
                loopInterval = null;
            }
            loopCounter = 0;
            document.getElementById('loopCounter').textContent = loopCounter;
            document.getElementById('loopLog').innerHTML = '<div class="log-entry">üîÑ Loop logs will appear here...</div>';
        }

        function addLoopLog(message) {
            const logContainer = document.getElementById('loopLog');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Data Fetching Demo
        async function fetchUserData() {
            const userId = document.getElementById('userIdInput').value;
            const userDataDiv = document.getElementById('userData');
            
            userDataDiv.innerHTML = '<p>‚è≥ Loading...</p>';
            
            try {
                const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
                const user = await response.json();
                
                userDataDiv.innerHTML = `
                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h4 style="color: #667eea; margin-bottom: 10px;">‚úÖ Data Fetched Successfully!</h4>
                        <p><strong>Name:</strong> ${user.name}</p>
                        <p><strong>Email:</strong> ${user.email}</p>
                        <p><strong>Phone:</strong> ${user.phone}</p>
                        <p><strong>Company:</strong> ${user.company.name}</p>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                            üí° This simulates fetching data inside useEffect with async/await
                        </p>
                    </div>
                `;
            } catch (error) {
                userDataDiv.innerHTML = `<p style="color: red;">‚ùå Error: ${error.message}</p>`;
            }
        }

        // Quiz Toggle Function
        function toggleAnswer(questionNumber) {
            const answer = document.getElementById(`answer${questionNumber}`);
            const button = answer.previousElementSibling;
            
            if (answer.classList.contains('show')) {
                answer.classList.remove('show');
                button.textContent = 'Show Answer';
            } else {
                answer.classList.add('show');
                button.textContent = 'Hide Answer';
            }
        }

        // Initialize empty deps demo on page load
        window.addEventListener('load', () => {
            emptyDepsRuns = 1;
            document.getElementById('emptyDepsRuns').textContent = emptyDepsRuns;
        });
    </script>
</body>
</html>