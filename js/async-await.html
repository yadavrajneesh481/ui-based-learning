<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 17: Async/Await - Interactive Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        .home-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 15px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .home-link:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        .home-link:focus {
            outline: 2px solid #ffc107;
            outline-offset: 2px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }

        .section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        h2 {
            color: #764ba2;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .demo-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #e0e0e0;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .output {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            min-height: 50px;
            font-family: monospace;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .comparison-item h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .visual-demo {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .task-box {
            padding: 15px;
            border-radius: 8px;
            background: #fff;
            border: 2px solid #e0e0e0;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
        }

        .task-box.running {
            border-color: #ffc107;
            background: #fff9e6;
        }

        .task-box.completed {
            border-color: #4caf50;
            background: #e8f5e9;
        }

        .task-box.error {
            border-color: #f44336;
            background: #ffebee;
        }

        .interview-questions {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 30px;
            border-radius: 15px;
            margin-top: 40px;
        }

        .question-card {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #764ba2;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .question-card:hover {
            transform: translateX(5px);
        }

        .question-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .answer {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .answer.show {
            display: block;
        }

        .difficulty {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }

        .difficulty.easy {
            background: #4caf50;
            color: white;
        }

        .difficulty.medium {
            background: #ff9800;
            color: white;
        }

        .difficulty.hard {
            background: #f44336;
            color: white;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.8em;
            }
        }

        .timer {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        }

        .status-success {
            background: #4caf50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .status-pending {
            background: #ffc107;
            color: #333;
        }
    </style>
</head>

<body>
    <div class="container">
        <a href="index.html" class="home-link" aria-label="Return to JavaScript course homepage">üè† Back to Course Home</a>
        <h1>üöÄ Day 17: Async/Await</h1>
        <p class="subtitle">Modern JavaScript ke asynchronous operations ko handle karne ka sabse clean way</p>

        <!-- Introduction Section -->
        <div class="section">
            <h2>üìö Async/Await Kya Hai?</h2>
            <p><strong>Async/Await</strong> ek modern syntax hai jo <span class="highlight">Promises</span> ko likhne
                aur padhne mein aasan banata hai. Ye ES2017 (ES8) mein introduce hua tha.</p>
            <p><strong>Hinglish mein:</strong> Async/await basically Promises ka syntactic sugar hai. Matlab ye Promises
                ko hi use karta hai, lekin code ko synchronous jaisa dikhata hai, jisse padhna aur samajhna bahut aasan
                ho jata hai.</p>

            <div class="code-block">
                // Traditional Promise way
                function getData() {
                return fetchData()
                .then(response => response.json())
                .then(data => processData(data))
                .catch(error => handleError(error));
                }

                // Async/Await way - Zyada clean aur readable
                async function getData() {
                try {
                const response = await fetchData();
                const data = await response.json();
                return processData(data);
                } catch (error) {
                handleError(error);
                }
                }</div>
        </div>

        <!-- Async Keyword Section -->
        <div class="section">
            <h2>üîë Async Keyword</h2>
            <p><span class="highlight">async</span> keyword ko function ke aage lagane se woh function automatically ek
                <strong>Promise</strong> return karta hai.</p>

            <div class="code-block">
                // Ye function automatically Promise return karega
                async function greet() {
                return "Hello!"; // Automatically Promise.resolve("Hello!") ban jayega
                }

                greet().then(msg => console.log(msg)); // "Hello!"</div>

            <div class="demo-box">
                <h3>Demo: Async Function</h3>
                <button onclick="testAsyncFunction()">Run Async Function</button>
                <div id="asyncOutput" class="output">Output yahan dikhega...</div>
            </div>
        </div>

        <!-- Await Keyword Section -->
        <div class="section">
            <h2>‚è≥ Await Keyword</h2>
            <p><span class="highlight">await</span> keyword sirf <strong>async functions</strong> ke andar hi use ho
                sakta hai. Ye Promise ke resolve hone ka wait karta hai.</p>
            <p><strong>Important:</strong> Await Promise ko pause nahi karta, balki async function ke execution ko pause
                karta hai jab tak Promise resolve/reject na ho jaye.</p>

            <div class="code-block">
                async function fetchUserData() {
                console.log("Fetching user data...");

                // Ye line complete hone tak wait karega
                const response = await fetch('https://api.example.com/user');

                // Upar wali line complete hone ke baad hi ye chalega
                const data = await response.json();

                return data;
                }</div>

            <div class="demo-box">
                <h3>Demo: Await in Action</h3>
                <button onclick="demonstrateAwait()">Simulate API Call</button>
                <div id="awaitOutput" class="output">Output yahan dikhega...</div>
            </div>
        </div>

        <!-- Error Handling Section -->
        <div class="section">
            <h2>üõ° Error Handling with Try/Catch</h2>
            <p>Async/await ke saath errors ko handle karne ke liye hum <span class="highlight">try/catch</span> blocks
                use karte hain, jo synchronous code jaisa dikhta hai.</p>

            <div class="comparison">
                <div class="comparison-item">
                    <h3>Promise .catch()</h3>
                    <div class="code-block" style="font-size: 12px;">
                        fetch(url)
                        .then(res => res.json())
                        .then(data => console.log(data))
                        .catch(err => {
                        console.error(err);
                        });</div>
                </div>
                <div class="comparison-item">
                    <h3>Async/Await try/catch</h3>
                    <div class="code-block" style="font-size: 12px;">
                        try {
                        const res = await fetch(url);
                        const data = await res.json();
                        console.log(data);
                        } catch (err) {
                        console.error(err);
                        }</div>
                </div>
            </div>

            <div class="demo-box">
                <h3>Demo: Error Handling</h3>
                <button onclick="demonstrateErrorHandling(true)">Success Case</button>
                <button onclick="demonstrateErrorHandling(false)">Error Case</button>
                <div id="errorOutput" class="output">Output yahan dikhega...</div>
            </div>
        </div>

        <!-- Sequential vs Parallel Section -->
        <div class="section">
            <h2>‚ö° Sequential vs Parallel Execution</h2>
            <p>Ye async/await ka sabse important concept hai! Agar properly use na karein to performance suffer kar
                sakti hai.</p>

            <h3>Sequential Execution (Ek ke baad ek)</h3>
            <p>Jab ek operation complete ho, tab doosra start hota hai.</p>
            <div class="code-block">
                // Sequential - Total time: 5 seconds (2 + 3)
                async function sequential() {
                const result1 = await fetchData1(); // 2 seconds wait
                const result2 = await fetchData2(); // 3 seconds wait
                return [result1, result2];
                }</div>

            <h3>Parallel Execution (Saath mein)</h3>
            <p>Dono operations saath mein start hote hain aur jab dono complete ho jate hain tab result milta hai.</p>
            <div class="code-block">
                // Parallel - Total time: 3 seconds (max of 2 and 3)
                async function parallel() {
                const promise1 = fetchData1(); // Start immediately
                const promise2 = fetchData2(); // Start immediately

                const result1 = await promise1;
                const result2 = await promise2;
                return [result1, result2];
                }

                // Ya Promise.all() use karein
                async function parallelWithAll() {
                const results = await Promise.all([
                fetchData1(),
                fetchData2()
                ]);
                return results;
                }</div>

            <div class="demo-box">
                <h3>Interactive Demo: Sequential vs Parallel</h3>
                <div class="visual-demo" id="visualDemo">
                    <div class="task-box" id="task1">Task 1<br><small>2 sec</small></div>
                    <div class="task-box" id="task2">Task 2<br><small>3 sec</small></div>
                    <div class="task-box" id="task3">Task 3<br><small>1 sec</small></div>
                </div>
                <button onclick="runSequential()">Run Sequential</button>
                <button onclick="runParallel()">Run Parallel</button>
                <div class="timer" id="timer">Time: 0s</div>
                <div id="executionOutput" class="output">Click karo execution dekhne ke liye...</div>
            </div>
        </div>

        <!-- Practice Section -->
        <div class="section">
            <h2>üéØ Practice: Real API Data Fetch</h2>
            <p>Chaliye ek real example dekhte hain jahan hum JSONPlaceholder API se data fetch karenge.</p>

            <div class="demo-box">
                <h3>Fetch User Posts</h3>
                <button onclick="fetchUserPosts()">Fetch Posts</button>
                <button onclick="fetchMultipleUsers()">Fetch Multiple Users (Parallel)</button>
                <div id="apiOutput" class="output">Data yahan dikhega...</div>
            </div>
        </div>

        <!-- Interview Questions Section -->
        <div class="interview-questions">
            <h2 style="text-align: center; color: #764ba2; margin-bottom: 25px;">üìù Interview Questions</h2>

            <div class="question-card" onclick="toggleAnswer('q1')">
                <h4>Q1: Async/Await aur Promises mein kya difference hai? <span class="difficulty easy">EASY</span></h4>
                <div id="q1" class="answer">
                    <p><strong>Answer:</strong></p>
                    <p><strong>Technical:</strong> Async/await is syntactic sugar over Promises. It doesn't replace
                        Promises but provides a cleaner syntax.</p>
                    <p><strong>Hinglish:</strong> Async/await aur Promises ek hi cheez hain, bas likhne ka tarika alag
                        hai. Async/await Promises ko hi internally use karta hai, lekin code ko synchronous code jaisa
                        dikhata hai jo padhna aur maintain karna aasan hota hai.</p>
                    <ul>
                        <li><strong>Promises:</strong> .then() chains use karte hain</li>
                        <li><strong>Async/Await:</strong> Try/catch use karte hain, code linear dikhta hai</li>
                    </ul>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q2')">
                <h4>Q2: Await keyword ko async function ke bahar use kar sakte hain kya? <span
                        class="difficulty easy">EASY</span></h4>
                <div id="q2" class="answer">
                    <p><strong>Answer:</strong></p>
                    <p><strong>Technical:</strong> No, await can only be used inside async functions, except at the top
                        level of modules (ES2022+).</p>
                    <p><strong>Hinglish:</strong> Nahi, await keyword sirf async functions ke andar hi use ho sakta hai.
                        Lekin modern JavaScript (ES2022) mein top-level await bhi available hai modules mein.</p>
                    <div class="code-block" style="font-size: 12px;">
                        // ‚ùå Error - await without async
                        function test() {
                        const data = await fetchData(); // SyntaxError!
                        }

                        // ‚úÖ Correct
                        async function test() {
                        const data = await fetchData(); // Works!
                        }

                        // ‚úÖ Top-level await (in modules)
                        const data = await fetchData(); // ES2022+</div>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q3')">
                <h4>Q3: Sequential aur Parallel execution mein performance difference samjhao. <span
                        class="difficulty medium">MEDIUM</span></h4>
                <div id="q3" class="answer">
                    <p><strong>Answer:</strong></p>
                    <p><strong>Technical:</strong> Sequential execution waits for each operation to complete before
                        starting the next, while parallel execution starts all operations simultaneously.</p>
                    <p><strong>Hinglish:</strong></p>
                    <p><strong>Sequential:</strong> Agar teen operations hain jo 2s, 3s, aur 1s lete hain, to total time
                        hoga 6 seconds (2+3+1).</p>
                    <p><strong>Parallel:</strong> Wohi teen operations agar saath mein chalein to total time hoga sirf 3
                        seconds (maximum of 2,3,1).</p>
                    <p><strong>Best Practice:</strong> Agar operations ek doosre par dependent nahi hain (jaise alag
                        alag APIs se data fetch karna), to parallel execution use karo performance ke liye.</p>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q4')">
                <h4>Q4: Promise.all() aur individual awaits mein kya difference hai? <span
                        class="difficulty medium">MEDIUM</span></h4>
                <div id="q4" class="answer">
                    <p><strong>Answer:</strong></p>
                    <div class="code-block" style="font-size: 12px;">
                        // Individual awaits - Sequential
                        const a = await promise1();
                        const b = await promise2();
                        const c = await promise3();

                        // Promise.all() - Parallel
                        const [a, b, c] = await Promise.all([
                        promise1(),
                        promise2(),
                        promise3()
                        ]);</div>
                    <p><strong>Hinglish:</strong> Individual awaits sequential hota hai - ek ke baad ek execute hota
                        hai. Promise.all() parallel hai - saare promises ek saath start hote hain.</p>
                    <p><strong>Important:</strong> Promise.all() mein agar ek bhi promise reject ho jaye to poora fail
                        ho jata hai. Iske liye Promise.allSettled() use kar sakte ho jo sabka result deta hai chahe
                        reject ho ya resolve.</p>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q5')">
                <h4>Q5: Async function mein error handling ke different ways kya hain? <span
                        class="difficulty medium">MEDIUM</span></h4>
                <div id="q5" class="answer">
                    <p><strong>Answer:</strong></p>
                    <p><strong>1. Try/Catch Block (Recommended):</strong></p>
                    <div class="code-block" style="font-size: 12px;">
                        async function getData() {
                        try {
                        const data = await fetchData();
                        return data;
                        } catch (error) {
                        console.error('Error:', error);
                        throw error;
                        }
                        }</div>
                    <p><strong>2. Promise .catch():</strong></p>
                    <div class="code-block" style="font-size: 12px;">
                        async function getData() {
                        const data = await fetchData().catch(err => {
                        console.error('Error:', err);
                        return null;
                        });
                        return data;
                        }</div>
                    <p><strong>3. Calling function mein handle karo:</strong></p>
                    <div class="code-block" style="font-size: 12px;">
                        getData().catch(err => console.error(err));</div>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q6')">
                <h4>Q6: Async/await ke saath Promise.race() kaise use hota hai? <span
                        class="difficulty hard">HARD</span></h4>
                <div id="q6" class="answer">
                    <p><strong>Answer:</strong></p>
                    <p><strong>Technical:</strong> Promise.race() returns a promise that resolves or rejects as soon as
                        one of the promises resolves or rejects.</p>
                    <div class="code-block" style="font-size: 12px;">
                        async function fetchWithTimeout(url, timeout) {
                        const fetchPromise = fetch(url);
                        const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Timeout')), timeout)
                        );

                        // Jo pehle complete ho wo result dega
                        const response = await Promise.race([
                        fetchPromise,
                        timeoutPromise
                        ]);

                        return response;
                        }

                        // Usage
                        try {
                        const data = await fetchWithTimeout('api.com/data', 5000);
                        } catch (error) {
                        console.log('Request failed or timed out');
                        }</div>
                    <p><strong>Hinglish:</strong> Promise.race() mein jo promise pehle complete ho jata hai (resolve ya
                        reject), wohi result milta hai. Ye timeout implement karne ke liye bahut useful hai.</p>
                </div>
            </div>

            <div class="question-card" onclick="toggleAnswer('q7')">
                <h4>Q7: Async/await ke potential pitfalls aur best practices kya hain? <span
                        class="difficulty hard">HARD</span></h4>
                <div id="q7" class="answer">
                    <p><strong>Common Pitfalls:</strong></p>
                    <ol>
                        <li><strong>Unnecessary Sequential Execution:</strong> Independent operations ko await se
                            sequential mat banao</li>
                        <li><strong>Missing Error Handling:</strong> Hamesha try/catch use karo</li>
                        <li><strong>Unhandled Promise Rejections:</strong> Async functions ko call karte waqt .catch()
                            lagao</li>
                        <li><strong>Blocking Event Loop:</strong> Long running operations ko properly handle karo</li>
                    </ol>
                    <p><strong>Best Practices:</strong></p>
                    <ul>
                        <li>Independent operations ke liye Promise.all() use karo</li>
                        <li>Always add error handling with try/catch</li>
                        <li>Meaningful error messages do</li>
                        <li>Async/await ko loops mein carefully use karo</li>
                        <li>Memory leaks se bacho - cleanup properly</li>
                    </ul>
                    <div class="code-block" style="font-size: 12px;">
                        // ‚ùå Bad - Sequential when not needed
                        async function bad() {
                        const user = await getUser();
                        const posts = await getPosts(); // Doesn't depend on user
                        return { user, posts };
                        }

                        // ‚úÖ Good - Parallel execution
                        async function good() {
                        const [user, posts] = await Promise.all([
                        getUser(),
                        getPosts()
                        ]);
                        return { user, posts };
                        }</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Test Async Function
        async function testAsyncFunction() {
            const output = document.getElementById('asyncOutput');
            output.innerHTML = '<div class="loading"></div> Running...';

            async function greet(name) {
                return `Hello, ${name}!`;
            }

            try {
                const result = await greet('Developer');
                output.innerHTML = `
                    <strong>Result:</strong> ${result}<br>
                    <strong>Type:</strong> ${typeof greet('Test')} (Promise object)<br>
                    <span class="status-badge status-success">Success</span>
                `;
            } catch (error) {
                output.innerHTML = `<span class="status-badge status-error">Error: ${error.message}</span>`;
            }
        }

        // Demonstrate Await
        async function demonstrateAwait() {
            const output = document.getElementById('awaitOutput');
            output.innerHTML = '<div class="loading"></div> Fetching data...';

            // Simulate API call
            function simulateAPICall(delay, data) {
                return new Promise(resolve => {
                    setTimeout(() => resolve(data), delay);
                });
            }

            try {
                const step1 = await simulateAPICall(1000, 'Step 1: Connected to server');
                output.innerHTML = step1 + '<br>';

                const step2 = await simulateAPICall(1000, 'Step 2: Authenticated user');
                output.innerHTML += step2 + '<br>';

                const step3 = await simulateAPICall(1000, 'Step 3: Data received');
                output.innerHTML += step3 + '<br>';
                output.innerHTML += '<span class="status-badge status-success">Complete!</span>';
            } catch (error) {
                output.innerHTML = `<span class="status-badge status-error">Error: ${error.message}</span>`;
            }
        }

        // Error Handling Demo
        async function demonstrateErrorHandling(shouldSucceed) {
            const output = document.getElementById('errorOutput');
            output.innerHTML = '<div class="loading"></div> Processing...';

            function riskyOperation(shouldSucceed) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (shouldSucceed) {
                            resolve('Operation successful! ‚úÖ');
                        } else {
                            reject(new Error('Operation failed! Network error occurred.'));
                        }
                    }, 1500);
                });
            }

            try {
                const result = await riskyOperation(shouldSucceed);
                output.innerHTML = `
                    <span class="status-badge status-success">Success</span><br>
                    ${result}
                `;
            } catch (error) {
                output.innerHTML = `
                    <span class="status-badge status-error">Caught Error</span><br>
                    <strong>Error Message:</strong> ${error.message}<br>
                    <small>Try/catch ne error ko successfully handle kar liya!</small>
                `;
            }
        }

        // Sequential Execution
        let timer;
        let startTime;

        function updateTimer() {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('timer').textContent = `Time: ${elapsed}s`;
        }

        async function runSequential() {
            const output = document.getElementById('executionOutput');
            const tasks = [
                document.getElementById('task1'),
                document.getElementById('task2'),
                document.getElementById('task3')
            ];

            // Reset
            tasks.forEach(t => t.className = 'task-box');
            output.innerHTML = 'Starting Sequential Execution...<br>';
            startTime = Date.now();
            timer = setInterval(updateTimer, 100);

            try {
                tasks[0].className = 'task-box running';
                await new Promise(resolve => setTimeout(resolve, 2000));
                tasks[0].className = 'task-box completed';
                output.innerHTML += 'Task 1 completed (2s)<br>';

                tasks[1].className = 'task-box running';
                await new Promise(resolve => setTimeout(resolve, 3000));
                tasks[1].className = 'task-box completed';
                output.innerHTML += 'Task 2 completed (3s)<br>';

                tasks[2].className = 'task-box running';
                await new Promise(resolve => setTimeout(resolve, 1000));
                tasks[2].className = 'task-box completed';
                output.innerHTML += 'Task 3 completed (1s)<br>';

                clearInterval(timer);
                const total = ((Date.now() - startTime) / 1000).toFixed(1);
                output.innerHTML += `<strong>Total Time: ${total}s</strong> (2 + 3 + 1)`;
            } catch (error) {
                clearInterval(timer);
                output.innerHTML += `<span class="status-badge status-error">Error occurred</span>`;
            }
        }

        async function runParallel() {
            const output = document.getElementById('executionOutput');
            const tasks = [
                document.getElementById('task1'),
                document.getElementById('task2'),
                document.getElementById('task3')
            ];

            // Reset
            tasks.forEach(t => t.className = 'task-box');
            output.innerHTML = 'Starting Parallel Execution...<br>';
            startTime = Date.now();
            timer = setInterval(updateTimer, 100);

            try {
                // Start all tasks simultaneously
                tasks.forEach(t => t.className = 'task-box running');

                const task1 = new Promise(resolve => {
                    setTimeout(() => {
                        tasks[0].className = 'task-box completed';
                        output.innerHTML += 'Task 1 completed (2s)<br>';
                        resolve();
                    }, 2000);
                });

                const task2 = new Promise(resolve => {
                    setTimeout(() => {
                        tasks[1].className = 'task-box completed';
                        output.innerHTML += 'Task 2 completed (3s)<br>';
                        resolve();
                    }, 3000);
                });

                const task3 = new Promise(resolve => {
                    setTimeout(() => {
                        tasks[2].className = 'task-box completed';
                        output.innerHTML += 'Task 3 completed (1s)<br>';
                        resolve();
                    }, 1000);
                });

                // Wait for all to complete
                await Promise.all([task1, task2, task3]);

                clearInterval(timer);
                const total = ((Date.now() - startTime) / 1000).toFixed(1);
                output.innerHTML += `<strong>Total Time: ${total}s</strong> (max of 2, 3, 1)`;
            } catch (error) {
                clearInterval(timer);
                output.innerHTML += `<span class="status-badge status-error">Error occurred</span>`;
            }
        }

        // Fetch User Posts
        async function fetchUserPosts() {
            const output = document.getElementById('apiOutput');
            output.innerHTML = '<div class="loading"></div> Fetching posts from JSONPlaceholder...';

            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=3');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const posts = await response.json();

                output.innerHTML = '<strong>Posts fetched successfully:</strong><br><br>';
                posts.forEach(post => {
                    output.innerHTML += `
                        <div style="background: white; padding: 10px; margin: 10px 0; border-radius: 5px; border-left: 3px solid #667eea;">
                            <strong>Post ${post.id}:</strong> ${post.title}<br>
                            <small style="color: #666;">${post.body.substring(0, 80)}...</small>
                        </div>
                    `;
                });
                output.innerHTML += '<span class="status-badge status-success">Fetch Complete!</span>';
            } catch (error) {
                output.innerHTML = `
                    <span class="status-badge status-error">Error</span><br>
                    <strong>Message:</strong> ${error.message}<br>
                    <small>Make sure you're connected to the internet.</small>
                `;
            }
        }

        // Fetch Multiple Users in Parallel
        async function fetchMultipleUsers() {
            const output = document.getElementById('apiOutput');
            output.innerHTML = '<div class="loading"></div> Fetching multiple users in parallel...';

            const startTime = Date.now();

            try {
                // Fetch 3 users in parallel using Promise.all
                const [user1, user2, user3] = await Promise.all([
                    fetch('https://jsonplaceholder.typicode.com/users/1').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/users/2').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/users/3').then(r => r.json())
                ]);

                const endTime = Date.now();
                const timeTaken = ((endTime - startTime) / 1000).toFixed(2);

                output.innerHTML = `<strong>3 Users fetched in parallel (Time: ${timeTaken}s):</strong><br><br>`;

                [user1, user2, user3].forEach(user => {
                    output.innerHTML += `
                        <div style="background: white; padding: 10px; margin: 10px 0; border-radius: 5px; border-left: 3px solid #764ba2;">
                            <strong>${user.name}</strong> (@${user.username})<br>
                            <small>Email: ${user.email}</small><br>
                            <small>Company: ${user.company.name}</small>
                        </div>
                    `;
                });

                output.innerHTML += `
                    <span class="status-badge status-success">All fetched in ${timeTaken}s!</span><br>
                    <small>Agar sequential hota to 3x time lagta! üöÄ</small>
                `;
            } catch (error) {
                output.innerHTML = `
                    <span class="status-badge status-error">Error</span><br>
                    <strong>Message:</strong> ${error.message}
                `;
            }
        }

        // Toggle answer visibility
        function toggleAnswer(id) {
            const answer = document.getElementById(id);
            answer.classList.toggle('show');
        }
    </script>
</body>

</html>